<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Palaso</name>
    </assembly>
    <members>
        <member name="T:Palaso.Base32.Base32Convert">
            <summary>
             base32 encoding and decoding as defined by RFC4648
             http://rfc.net/rfc4648.html
            </summary>
        </member>
        <member name="M:Palaso.Base32.Base32Convert.ToBase32HexString(System.Collections.Generic.IEnumerable{System.Byte},Palaso.Base32.Base32FormattingOptions)">
            <summary>
            base32hex encoding as defined by RFC4648
            http://rfc.net/rfc4648.html
            One property with this alphabet, which the base64 and base32
            alphabets lack, is that encoded data maintains its sort order when
            the encoded data is compared bit-wise.    
            </summary>
            <remarks>
            This is suitable for encoding sort keys in xml documents such
            that xslt 1 can produce a proper ordering.
            </remarks>
        </member>
        <member name="M:Palaso.Base32.Base32Convert.FromBase32HexString(System.String,Palaso.Base32.Base32FormattingOptions)">
            <summary>
            base32hex decoding as defined by RFC4648
            http://rfc.net/rfc4648.html
            One property with this alphabet, which the base64 and base32
            alphabets lack, is that encoded data maintains its sort order when
            the encoded data is compared bit-wise.    
            </summary>
            <remarks>
            This is suitable for encoding sort keys in xml documents such
            that xslt 1 can produce a proper ordering.
            </remarks>
        </member>
        <member name="F:Palaso.Base32.Base32FormattingOptions.None">
            <summary>
            Does not insert '=' at end of the string to pad it so that the string length is a multiple
            of 8
            </summary>
        </member>
        <member name="F:Palaso.Base32.Base32FormattingOptions.InsertTrailingPadding">
            <summary>
            Inserts '=' at the end of the string to pad it so that the string length is a multiple
            of 8
            </summary>
        </member>
        <member name="T:Palaso.Code.RequireThat">
            <summary>
            Allows statements like:
            	RequireThat.Directory(dir).Exists();
            	RequireThat.Directory(dir).DoesNotExist();
            	RequireThat.File(path).DoesNotExist();
            	RequireThat.File(path).Directory.Exists();
            </summary>
        </member>
        <member name="P:Palaso.Code.RequireThat.FileChecker.Directory">
            <summary>
            Allows us to say RequireThat.File("foo/blah.txt").Directory.Exists();
            </summary>
            <returns></returns>
        </member>
        <member name="T:Palaso.Data.PreciseDateTime">
            <summary>
            Pseudo precise in that the ticks value returned does not actually
            conform to the definition of Ticks but will be strictly increasing
            each time it is called.
            </summary>
        </member>
        <member name="M:Palaso.Data.ResultSet`1.Coalesce(System.String,System.Predicate{System.Object})">
            <summary>
            Removes any entries for which the predicate canBeRemoved is true 
              and another record token with the same repository Id exists
            </summary>
            <param name="fieldName"></param>
            <param name="canBeRemoved"></param>
        </member>
        <member name="M:Palaso.Data.ResultSetCache`1.UpdateItemInCache(`0)">
            <summary>
            Call this method every time a cached item changes. This method verifies that the item you are trying to update exists int he repository.
            </summary>
            <param name="item"></param>
        </member>
        <member name="T:Palaso.Data.ValidationException">
            <summary>
             General data validation exception
            </summary>
        </member>
        <member name="M:Palaso.Data.ValidationException.#ctor(System.String)">
            <summary>
             Constructor with a helpful error message.
            </summary>
            <param name="message"></param>
        </member>
        <member name="P:Palaso.Email.EmailMessage.Subject">
            <summary>
            the  e-mail subject
            </summary>
        </member>
        <member name="P:Palaso.Email.EmailMessage.Body">
            <summary>
            
            </summary>
        </member>
        <member name="M:Palaso.Email.MAPI.SendMail(System.String,System.String,System.Int32)">
            <summary>
            
            </summary>
            <param name="strSubject"></param>
            <param name="strBody"></param>
            <param name="how"></param>
            <returns>true if successful</returns>
        </member>
        <member name="T:Palaso.Func`1">
            <summary>
            Common delegate definition
            </summary>
            <summary>
            Common delegate definition
            </summary>
        </member>
        <member name="T:Palaso.Func`2">
            <summary>
            Common delegate definition
            </summary>
        </member>
        <member name="T:Palaso.Func`3">
            <summary>
            Common delegate definition
            </summary>
        </member>
        <member name="T:Palaso.Func`4">
            <summary>
            Common delegate definition
            </summary>
        </member>
        <member name="T:Palaso.Func`5">
            <summary>
            Common delegate definition
            </summary>
        </member>
        <member name="T:Palaso.Func`6">
            <summary>
            Common delegate definition
            </summary>
        </member>
        <member name="T:Palaso.Func`7">
            <summary>
            Common delegate definition
            </summary>
        </member>
        <member name="T:Palaso.Func`8">
            <summary>
            Common delegate definition
            </summary>
        </member>
        <member name="T:Palaso.Func`9">
            <summary>
            Common delegate definition
            </summary>
        </member>
        <member name="T:Palaso.Func`10">
            <summary>
            Common delegate definition
            </summary>
        </member>
        <member name="T:Palaso.Proc">
            <summary>
            Common delegate definition
            </summary>
        </member>
        <member name="T:Palaso.Proc`1">
            <summary>
            Common delegate definition
            </summary>
        </member>
        <member name="T:Palaso.Proc`2">
            <summary>
            Common delegate definition
            </summary>
        </member>
        <member name="T:Palaso.Proc`3">
            <summary>
            Common delegate definition
            </summary>
        </member>
        <member name="T:Palaso.Proc`4">
            <summary>
            Common delegate definition
            </summary>
        </member>
        <member name="T:Palaso.Proc`5">
            <summary>
            Common delegate definition
            </summary>
        </member>
        <member name="T:Palaso.Proc`6">
            <summary>
            Common delegate definition
            </summary>
        </member>
        <member name="T:Palaso.Proc`7">
            <summary>
            Common delegate definition
            </summary>
        </member>
        <member name="T:Palaso.Proc`8">
            <summary>
            Common delegate definition
            </summary>
        </member>
        <member name="T:Palaso.Proc`9">
            <summary>
            Common delegate definition
            </summary>
        </member>
        <member name="T:Rhino.Commons.DisposableAction`1">
            <summary>
            Better sytnax for context operation.
            Wraps a delegate that is executed when the Dispose method is called.
            This allows to do context sensitive things easily.
            Basically, it mimics Java's anonymous classes.
            </summary>
            <typeparam name="T">
            The type of the parameter that the delegate to execute on dispose
            will accept
            </typeparam>
        </member>
        <member name="M:Rhino.Commons.DisposableAction`1.#ctor(Palaso.Proc{`0},`0)">
            <summary>
            Initializes a new instance of the <see cref="T:Rhino.Commons.DisposableAction`1"/> class.
            </summary>
            <param name="action">The action to execute on dispose</param>
            <param name="val">The value that will be passed to the action on dispose</param>
        </member>
        <member name="M:Rhino.Commons.DisposableAction`1.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="P:Rhino.Commons.DisposableAction`1.Value">
            <summary>
            Gets the value associated with this action
            </summary>
            <value>The value.</value>
        </member>
        <member name="T:Rhino.Commons.DisposableAction">
            <summary>
            Better sytnax for context operation.
            Wraps a delegate that is executed when the Dispose method is called.
            This allows to do context sensitive things easily.
            Basically, it mimics Java's anonymous classes.
            </summary>
        </member>
        <member name="M:Rhino.Commons.DisposableAction.#ctor(Palaso.Proc)">
            <summary>
            Initializes a new instance of the <see cref="T:Rhino.Commons.DisposableAction"/> class.
            </summary>
            <param name="action">The action to execute on dispose</param>
        </member>
        <member name="M:Rhino.Commons.DisposableAction.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="M:Palaso.Extensions.DateTimeExtensions.ParseDateTimePermissively(System.String)">
            <summary>
            We have this permsissive business because we released versions of SayMore which used the local
            format, rather than a universal one.
            </summary>
        </member>
        <member name="M:Palaso.Extensions.StringExtensions.FormatWithErrorStringInsteadOfException(System.String,System.Object[])">
            <summary>
            normal string.format will throw if it can't do the format; this is dangerous if you're, for example
            just logging stuff that might contain messed up strings (myWorkSafe paths)
            </summary>
        </member>
        <member name="M:Palaso.Extensions.StringExtensions.CombineForPath(System.String,System.String[])">
            <summary>
            Similar to Path.Combine, but it combines as may parts as you have into a single, platform-appropriate path.
            </summary>
            <example> string path = "my".Combine("stuff", "toys", "ball.txt")</example>
        </member>
        <member name="M:Palaso.Extensions.StringExtensions.SanitizeFilename(System.String,System.Char)">
            <summary>
            Finds and replaces invalid characters in a filename
            </summary>
            <param name="input">the string to clean</param>
            <param name="errorChar">the character which replaces bad characters</param>
        </member>
        <member name="M:Palaso.Extensions.StringExtensions.SanitizePath(System.String,System.Char)">
            <summary>
            Finds and replaces invalid characters in a path
            </summary>
            <param name="input">the string to clean</param>
            <param name="errorChar">the character which replaces bad characters</param>
        </member>
        <member name="M:Palaso.i18n.StringCatalog.#ctor">
            <summary>
            Construct with no actual string file
            </summary>
        </member>
        <member name="M:Palaso.i18n.StringCatalog.#ctor(System.String,System.Single)">
            <summary>
            Construct with no actual string file
            </summary>
        </member>
        <member name="M:Palaso.i18n.StringCatalog.GetFormatted(System.String,System.String,System.Object[])">
            <summary>
            Clients should use this rather than running string.Format themselves,
            because this has error checking and a helpful message, should the number
            of parameters be wrong.
            </summary>
            <param name="id"></param>
            <param name="translationNotes">just for the string scanner's use</param>
            <param name="args">arguments to the string, used in string.format</param>
            <returns></returns>
        </member>
        <member name="T:Palaso.CommandLineProcessing.CommandLineRunner">
            <summary>
             
            </summary>
        </member>
        <member name="T:Palaso.CommandLineProcessing.ProcessStream">
            <summary>
            This is class originally from  SeemabK (seemabk@yahoo.com).  It has been enhanced for chorus.
            </summary>
        </member>
        <member name="M:Palaso.CommandLineProcessing.ProcessOutputReader.Read(System.Diagnostics.Process@,System.Int32,Palaso.Progress.LogBox.IProgress)">
            <summary>
            Safely read the streams of the process
            </summary>
            <param name="process"></param>
            <param name="secondsBeforeTimeOut"></param>
            <returns>true if the process completed before the timeout or cancellation</returns>
        </member>
        <member name="M:Palaso.IO.FileUtils.GrepFile(System.String,System.String,System.String)">
            <summary>
            NB: This will show a dialog if the file writing can't be done (subject to Palaso.Reporting settings).
            It will throw whatever exception was encountered, if the user can't resolve it.
            </summary>
            <param name="inputPath"></param>
            <param name="pattern"></param>
            <param name="replaceWith"></param>
        </member>
        <member name="M:Palaso.IO.FileUtils.CheckValidPathname(System.String,System.String)">
            <summary>
            Make sure the given <paramref name="pathToFile"/> file is 'valid'.
            
            Valid means that
            	1. <paramref name="pathToFile"/> must not be null or an empty string
            	2. <paramref name="pathToFile"/> must exist, and
            	3. The extension for <paramref name="pathToFile"/> must equal <paramref name="expectedExtension"/>
            		(Or both must be null)
            </summary>
        </member>
        <member name="M:Palaso.IO.FileUtils.ReplaceFileWithUserInteractionIfNeeded(System.String,System.String,System.String)">
            <summary>
            If there is a problem doing the replace, a dialog is shown which tells the user
            what happened, and lets them try to fix it.  It also lets them "Give up", in 
            which case this returns False.
            </summary>
            <param name="sourcePath"></param>
            <param name="destinationPath"></param>
            <param name="backupPath">can be null if you don't want a replacement</param>
            <returns>if the user gives up, throws whatever exception the file system gave</returns>
        </member>
        <member name="T:Palaso.Events.EventArgs`1">
            <summary>
            Generic version of EveryArgs, allow to avoid 
            defining custom  EventArgs types 
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Palaso.Events.EventArgs`1.#ctor(`0)">
            <summary>
            Initializes a new instance of the <see cref="T:Palaso.Events.EventArgs`1"/> class.
            </summary>
            <param name="item">The item.</param>
        </member>
        <member name="P:Palaso.Events.EventArgs`1.Item">
            <summary>
            Gets or sets the item for this event args
            </summary>
            <value>The item.</value>
        </member>
        <member name="M:Palaso.IO.FolderUtils.CopyFolderToTempFolder(System.String)">
            <summary>
            Makes a full copies of the specified folder in the system's temporary folder.
            If the copy fails at any point in the process, the user is notified of the
            problem and an attempt is made to remove the destination folder if the failure
            happened part way through the process.
            </summary>
            <param name="srcFolder">Folder to copy</param>
            <returns>Null if the copy was unsuccessful, otherwise the path to the copied folder</returns>
        </member>
        <member name="M:Palaso.IO.FolderUtils.CopyFolder(System.String,System.String)">
            <summary>
            Makes a copy of the specifed source folder and its contents in the specified
            destination folder. The copy has the same folder name as the source, but ends up
            as a sub folder of the specified destination folder. The destination folder must
            already exist. If the copy fails at any point in the process, the user is notified
            of the problem and an attempt is made to remove the destination folder if the
            failure happened part way through the process.
            </summary>
            <param name="srcFolder">Folder being copied</param>
            <param name="dstFolderParent">Destination folder where source folder and its contents are copied</param>
            <returns>true if successful, otherwise, false.</returns>
        </member>
        <member name="M:Palaso.IO.FolderUtils.CopyFolderContents(System.String,System.String)">
            <summary>
            Copies the specified source folder's contents to the specified destination folder.
            If the destination folder does not exist, it will be created first. If the source
            folder contains sub folders, those and their content will also be copied. If the
            copy fails at any point in the process, the user is notified of the problem and
            an attempt is made to remove the destination folder if the failure happened part
            way through the process.
            </summary>
            <param name="sourcePath">Folder whose contents will be copied</param>
            <param name="destinationPath">Destination folder receiving the content of the source folder</param>
            <returns>true if successful, otherwise, false.</returns>
            
        </member>
        <member name="M:Palaso.IO.FolderUtils.MoveDirectorySafely(System.String,System.String)">
            <summary>
            Directory.Move fails if the src and dest are on different partitions (e.g., temp and documents are on differen drives).
            This will do a move if it can, else do a copy followed by a delete.
            </summary>
        </member>
        <member name="M:Palaso.IO.FolderUtils.GetSafeDirectories(System.String)">
            <summary>
            Return subfolders of <paramref name="path"/> that are not system or hidden.
            </summary>
            <param name="path">Directory path to look in.</param>
            <returns>Zero or more directory names that are not system or hidden.</returns>
        </member>
        <member name="T:Palaso.IO.TempFile">
            <summary>
            This is useful a temporary file is needed. When it is disposed, it will delete the file.
            </summary>
            <example>using(f = new TempFile())</example>
        </member>
        <member name="M:Palaso.IO.TempFile.TrackExisting(System.String)">
            <summary>
            Create a TempFile based on a pre-existing file, which will be deleted when this is disposed.
            </summary>
        </member>
        <member name="M:Palaso.IO.TempFile.WithExtension(System.String)">
            <summary>
            Use this one when it's important to have a certain file extension 
            </summary>
            <param name="extension">with or with out '.', will work the same</param>
        </member>
        <member name="M:Palaso.IO.TempFile.FromResource(System.IO.Stream,System.String)">
            <summary>
            Used to make a real file out of a resource for the purpose of testing 
            </summary>
            <param name="resource">e.g., an audio resource</param>
            <param name="extension">with or with out '.', will work the same</param>
        </member>
        <member name="M:Palaso.IO.TempFile.FromResource(System.Byte[],System.String)">
            <summary>
            Used to make a real file out of a resource for the purpose of testing 
            </summary>
            <param name="resource">e.g., a video resource</param>
            <param name="extension">with or with out '.', will work the same</param>
        </member>
        <member name="M:Palaso.IO.TempFile.MoveTo(System.String)">
            <summary>
            Used to move a file to a new path 
            </summary>
        </member>
        <member name="M:Palaso.Code.ReentryDetecter.AndThrow">
            <example>
              using (Detect.Reentry(this, "OnPropertyValueChanged").AndThrow())
              {
            </example>
        </member>
        <member name="P:Palaso.Code.ReentryDetecter.DidReenter">
            <example>
              using (var x = Detect.Reentry(this, "OnPropertyValueChanged"))
              {
                    if(x.DidReenter)
                        return;
            </example>
        </member>
        <member name="T:Palaso.Code.Guard">
            <summary>
            Helper class for guard statements, which allow prettier
            code for guard clauses
            </summary>
        </member>
        <member name="M:Palaso.Code.Guard.Against(System.Boolean,System.String)">
            <summary>
            Will throw a <see cref="T:System.InvalidOperationException"/> if the assertion
            is true, with the specificied message.
            </summary>
            <param name="assertion">if set to <c>true</c> [assertion].</param>
            <param name="message">The message.</param>
            <example>
            Sample usage:
            <code>
            Guard.Against(string.IsNullOrEmpty(name), "Name must have a value");
            </code>
            </example>
        </member>
        <member name="M:Palaso.Code.Guard.Against``1(System.Boolean,System.String)">
            <summary>
            Will throw exception of type <typeparamref name="TException"/>
            with the specified message if the assertion is true
            </summary>
            <typeparam name="TException"></typeparam>
            <param name="assertion">if set to <c>true</c> [assertion].</param>
            <param name="message">The message.</param>
            <example>
            Sample usage:
            <code>
            <![CDATA[
            Guard.Against<ArgumentException>(string.IsNullOrEmpty(name), "Name must have a value");
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Palaso.IO.FileLocator.GetFileDistributedWithApplication(System.Boolean,System.String[])">
            <summary>
            Find a file which, on a development machine, lives in [solution]/[distFileFolderName]/[subPath],
            and when installed, lives in 
            [applicationFolder]/[distFileFolderName]/[subPath1]/[subPathN]  or
            [applicationFolder]/[subPath]/[subPathN]
            </summary>
            <example>GetFileDistributedWithApplication("info", "releaseNotes.htm");</example>
        </member>
        <member name="M:Palaso.IO.FileLocator.GetFileDistributedWithApplication(System.String[])">
            <summary>
            Find a file which MUST EXIST. On a development machine, lives in [solution]/[distFileFolderName]/[subPath],
            and when installed, lives in 
            [applicationFolder]/[distFileFolderName]/[subPath1]/[subPathN]  or
            [applicationFolder]/[subPath]/[subPathN]
            </summary>
            <example>GetFileDistributedWithApplication("info", "releaseNotes.htm");</example>
        </member>
        <member name="M:Palaso.IO.FileLocator.GetDirectoryDistributedWithApplication(System.Boolean,System.String[])">
            <summary>
            Find a file which, on a development machine, lives in [solution]/DistFiles/[subPath],
            and when installed, lives in 
            [applicationFolder]/[subPath1]/[subPathN]
            </summary>
            <example>GetFileDistributedWithApplication("info", "releaseNotes.htm");</example>
        </member>
        <member name="M:Palaso.IO.FileLocator.GetDirectoryDistributedWithApplication(System.String[])">
            <summary>
            Find a directory which MUST EXIST. On a development machine, lives in [solution]/DistFiles/[subPath],
            and when installed, lives in 
            [applicationFolder]/[subPath1]/[subPathN]
            </summary>
            <example>GetFileDistributedWithApplication("info", "releaseNotes.htm");</example>
        </member>
        <member name="M:Palaso.IO.FileLocator.LocateInProgramFiles(System.String,System.Boolean,System.String[])">
            ------------------------------------------------------------------------------------
            <summary>
            Locates the specified program in the program files folder, returning the full path
            (including the exeName). Searching is only done in the OS's program files folder(s)
            and sub folders. On a 64-bit Windows OS, both program files folders are searched.
            
            When subFoldersToSearch are specified:
            	- The specified sub folders are searched first.
            	- If fallBackToDeepSearch is true, then after the search in the specified sub
            	  folders fails, a deep search will be made in each of the sub folders, and
            	  if that fails, the entire program files folder (and all sub folders)
            	  is searched.
            	- If fallBackToDeepSearch is false, only subFoldersToSearch are searched.
            	
            When subFoldersToSearch are not specified:
            	- If fallBackToDeepSearch is true, then the entire program files folder (and all
            	  (sub folders) is searched.
            	- If fallBackToDeepSearch is false, then only the top-level program files
            	  folder is searched.
            </summary>
            ------------------------------------------------------------------------------------
        </member>
        <member name="M:Palaso.IO.FileLocator.LocateInProgramFilesUsingShallowSearch(System.String,System.String[])">
            ------------------------------------------------------------------------------------
        </member>
        <member name="M:Palaso.IO.FileLocator.LocateInProgramFilesUsingDeepSearch(System.String,System.String[])">
            ------------------------------------------------------------------------------------
        </member>
        <member name="M:Palaso.IO.FileLocator.LocateInProgramFilesFolder(System.String,System.IO.SearchOption,System.String[])">
            ------------------------------------------------------------------------------------
        </member>
        <member name="M:Palaso.IO.FileLocator.GetFromRegistryProgramThatOpensFileType(System.String)">
            ------------------------------------------------------------------------------------
            <summary>
            Searches the registry and returns the full path to the application program used to
            open files having the specified extention. The fileExtension can be with or without
            the preceding period. If the command cannot be found in the registry, then null is
            returned. If a command in the registry is found, but it refers to a program file
            that does not exist, null is returned.
            </summary>
            ------------------------------------------------------------------------------------
        </member>
        <member name="M:Palaso.IO.FileLocator.GetPossibleProgramFilesFolders">
            ------------------------------------------------------------------------------------
            <summary>
            Returns a list of the possible paths to the program files folder, taking into
            account that 2 often (or always?) exist in a Win64 OS (i.e. "Program Files" and
            "Program Files (x86)").
            </summary>
            ------------------------------------------------------------------------------------
        </member>
        <member name="P:Palaso.IO.FileLocator.DirectoryOfApplicationOrSolution">
            <summary>
            Gives the directory of either the project folder (if running from visual studio), or
            the installation folder.  Helpful for finding templates and things; by using this,
            you don't have to copy those files into the build directory during development.
            It assumes your build directory has "output" as part of its path.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Palaso.Migration.IMigrationStrategy">
            <summary>
             Used by Migrator to migrate from one version to another.
            </summary>
        </member>
        <member name="T:Palaso.Migration.FolderMigrator">
            <summary>
             Migrates a set of files (of one type) in a folder matching an optional SearchPattern up to the given version using a set of strategies to migrate each
             version of the file.
            </summary>
        </member>
        <member name="M:Palaso.Migration.FolderMigrator.#ctor(System.Int32,System.String)">
            <summary>
             Constructor
            </summary>
            <param name="versionToMigrateTo">Target version to migrate to</param>
            <param name="sourcePath">FolderMigratorProblemHandler callback to pass exceptions thrown during migration</param>
        </member>
        <member name="M:Palaso.Migration.FolderMigrator.#ctor(System.Int32,System.String,Palaso.Migration.FolderMigrator.FolderMigratorProblemHandler)">
            <summary>
             Constructor with FolderMigratorProblemHandler which is passed a collection of exceptions thrown during migration.
            </summary>
            <param name="versionToMigrateTo">Target version to migrate to</param>
            <param name="sourcePath">Folder path containing files to migrate</param>
            <param name="problemHandler">Folder path containing files to migrate</param>
        </member>
        <member name="M:Palaso.Migration.FolderMigrator.OnFolderMigrationProblem(System.Collections.Generic.IEnumerable{Palaso.Migration.FolderMigrator.FolderMigratorProblem})">
            <summary>
             Default FolderMigrationProblemHandler, does nothing.
            </summary>
        </member>
        <member name="M:Palaso.Migration.FolderMigrator.Migrate">
            <summary>
             Perform the migration
            </summary>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="P:Palaso.Migration.FolderMigrator.SearchPattern">
            <summary>
             The pattern used to match files to migrate.
            </summary>
        </member>
        <member name="T:Palaso.Migration.FolderMigrator.FolderMigratorProblemHandler">
            <summary>
             A handler delegate for notification of issues encountered during migration.
            </summary>
            <param name="problems"></param>
        </member>
        <member name="T:Palaso.Migration.FolderMigrator.FolderMigratorProblem">
            <summary>
             FolderMigrationProblem contains information about exceptions thrown during execution
             of a migration strategy.
            </summary>
        </member>
        <member name="P:Palaso.Migration.FolderMigrator.FolderMigratorProblem.Exception">
            <summary>
             The exceptions that was thrown by the migration stragegy.
            </summary>
        </member>
        <member name="P:Palaso.Migration.FolderMigrator.FolderMigratorProblem.FilePath">
            <summary>
             The file being migrated when the problem occurred.
            </summary>
        </member>
        <member name="T:Palaso.Migration.XmlReaderWriterMigrationStrategy">
            <summary>
             Copies an xml file, giving an opportunity to inspect each node in the CopyNode method.
            </summary>
        </member>
        <member name="M:Palaso.Migration.XmlReaderWriterMigrationStrategy.Migrate(System.String,System.String)">
            <summary>
             Copies sourceFilePath to destinationFilePath calling CopyNode for each node read.
            </summary>
            <param name="source"></param>
            <param name="destinationFilePath"></param>
        </member>
        <member name="T:Palaso.Migration.XslMigrationStrategy">
            <summary>
            </summary>
        </member>
        <member name="M:Palaso.Migration.XslMigrationStrategy.#ctor(System.Int32,System.Int32,System.String)">
            <summary>
            </summary>
            <param name="fromVersion"></param>
            <param name="toVersion"></param>
            <param name="xslSource">A string reference to the source of the xslt</param>
        </member>
        <member name="M:Palaso.Migration.XslMigrationStrategy.Migrate(System.String,System.String)">
            <summary>
            </summary>
            <param name="source"></param>
            <param name="destinationFilePath"></param>
        </member>
        <member name="M:Palaso.Network.ProxyCredentialsRequestDialog.ReadProxyCredentials(System.String@,System.String@)">
            <summary>
            Get proxy creds from a place (not settings) that all palaso apps can share
            </summary>
            <returns>true if some credentials were found</returns>
        </member>
        <member name="M:Palaso.Network.ProxyCredentialsRequestDialog.GetCredentials(System.Boolean)">
            <summary>
            
            </summary>
            <param name="doTryStoredCredentials">Call it first with this true, but if that doesn't work, call with this
            false so that we ask the user again</param>
            <returns></returns>
        </member>
        <member name="F:Palaso.Network.ProxyCredentialsRequestDialog.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:Palaso.Network.ProxyCredentialsRequestDialog.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:Palaso.Network.ProxyCredentialsRequestDialog.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="M:Palaso.Network.RobustNetworkOperation.Do(System.Action{System.Net.IWebProxy},System.Action{System.String})">
            <summary>
            Perform a web action, trying various things to use a proxy if needed, including requesting
            (and remembering) user credentials from the user.
            </summary>
            <returns>the proxy information which was needed to complete the task, will THROW if it failed.</returns>
        </member>
        <member name="M:Palaso.Network.RobustNetworkOperation.ClearCredentialSettings">
            <summary>
            for testing
            </summary>
        </member>
        <member name="M:Palaso.Network.RobustNetworkOperation.DoHttpGetAndGetProxyInfo(System.String,System.String@,System.String@,System.String@,System.Action{System.String})">
            <summary>
            Used by Chorus to get proxy name, user name, and password of the remote repository.
            </summary>
            <returns>true if a proxy is needed. THROWS if it just can't get through</returns>
        </member>
        <member name="T:Palaso.Progress.AsyncCommand">
            <summary>
            An abstract base for an implementation of a command that will spawn a long operation
            </summary>
            <remarks>
            You should override the <see cref="M:Palaso.Progress.AsyncCommand.BeginInvokeCore"/> method to 
            invoke your operation using whichever asynchronous mechanism you prefer
            </remarks>
        </member>
        <member name="M:Palaso.Progress.AsyncCommand.#ctor">
            <summary>
            Standard constructor, protected because this is an abstract
            class
            </summary>
        </member>
        <member name="M:Palaso.Progress.AsyncCommand.BeginInvoke">
            <summary>
            Asynchronously executes the operation, returning immediately.
            </summary>
            <returns>
            Returns false if the operation was not <see cref="P:Palaso.Progress.AsyncCommand.Enabled"/>
            when we called the method, otherwise true.
            </returns>
            <remarks>
            The method automatically disables the operation once it is
            running, to prevent it accidentally being started again. It should
            only be called from the UI thread.
            </remarks>
        </member>
        <member name="M:Palaso.Progress.AsyncCommand.Cancel">
            <summary>
            Begin an attempt to cancel the operation
            </summary>
            <remarks>This should only be called from the UI thread</remarks>
        </member>
        <member name="M:Palaso.Progress.AsyncCommand.BeginInvokeCore">
            <summary>
            Override this method to invoke the actual
            long operation using your preferred async mode.
            </summary>
        </member>
        <member name="M:Palaso.Progress.AsyncCommand.OnFinish(System.EventArgs)">
            <summary>
            Raises the Finish event.
            </summary>
            <param name="e">Event data</param>
        </member>
        <member name="M:Palaso.Progress.AsyncCommand.OnError(Palaso.Progress.ErrorEventArgs)">
            <summary>
            Raises the Error event
            </summary>
            <param name="e">Event data</param>
        </member>
        <member name="P:Palaso.Progress.AsyncCommand.Enabled">
            <summary>
            This property can be used to enable/disable
            the command, and should be called only from 
            the UI thread
            </summary>
        </member>
        <member name="E:Palaso.Progress.AsyncCommand.EnabledChanged">
            <summary>
            Raised when the command is enabled and disabled
            </summary>
        </member>
        <member name="P:Palaso.Progress.AsyncCommand.Canceling">
            <summary>
            Gets a value which determines whether the operation is being cancelled
            </summary>
            <remarks>
            This may be called either from the UI, or by derived classes from the worker thread
            </remarks>
        </member>
        <member name="E:Palaso.Progress.AsyncCommand.BeginCancel">
            <summary>
            Raised when a cancel request is raised.
            </summary>
            <remarks>This will only be raised on the UI
            thread. Note that the operation may already have completed by the
            time the cancel event is raised, but you are guaranteed not to
            receive a <see cref="E:Palaso.Progress.AsyncCommand.Finish"/> or <see cref="E:Palaso.Progress.AsyncCommand.Error"/> event between a call to <see cref="M:Palaso.Progress.AsyncCommand.Cancel"/>
            and the BeginCancel event itself.
            </remarks> 
        </member>
        <member name="E:Palaso.Progress.AsyncCommand.Finish">
            <summary>
            Raised when the operation has finished
            </summary>
            <remarks>
            This will be raised on the worker thread, not the GUI thread. There are guaranteed to be
            no further events from the command after this event has been raised.
            </remarks>
        </member>
        <member name="E:Palaso.Progress.AsyncCommand.Error">
            <summary>
            Raised when the operation has finished, and an exception has ocurred
            </summary>
            <remarks>This will be raised on the worker thread, not the GUI thread. There are guaranteed to be
            no further events from the command after this event has been raised.</remarks>
        </member>
        <member name="T:Palaso.Progress.ErrorEventHandler">
            <summary>
            Delegate for the <see cref="E:Palaso.Progress.AsyncCommand.Error"/> event
            </summary>
        </member>
        <member name="T:Palaso.Progress.ErrorEventArgs">
            <summary>
            Class to contain the event data for the error event
            </summary>
        </member>
        <member name="M:Palaso.Progress.ErrorEventArgs.#ctor(System.Exception)">
            <summary>
            Standard constructor
            </summary>
            <param name="exception">The exception that ocurred, or null if an unspecified error ocurred</param>
        </member>
        <member name="P:Palaso.Progress.ErrorEventArgs.Exception">
            <summary>
            Gets the exception that occurred, or null if there was an unspecified error
            </summary>
        </member>
        <member name="T:Palaso.Progress.BackgroundWorkerState">
            <summary>
            Long-running tasks can be written to take one of these as an argument, and use it to notify others of their progress
            </summary>
        </member>
        <member name="T:Palaso.Progress.ProgressState">
            <summary>
            Long-running tasks can be written to take one of these as an argument, and use it to notify others of their progress
            </summary>
        </member>
        <member name="M:Palaso.Progress.ProgressState.CancelRequested(System.Object,System.EventArgs)">
            <summary>
            Normally, you'll wire the cancel button or whatever of the ui to this,
            then let the worker check our Cancel status in its inner loop.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="F:Palaso.Progress.ProgressState._isDisposed">
            <summary>
            True, if the object has been disposed.
            </summary>
        </member>
        <member name="M:Palaso.Progress.ProgressState.Finalize">
            <summary>
            Finalizer, in case client doesn't dispose it.
            Force Dispose(false) if not already called (i.e. _isDisposed is true)
            </summary>
            <remarks>
            In case some clients forget to dispose it directly.
            </remarks>
        </member>
        <member name="M:Palaso.Progress.ProgressState.Dispose">
            <summary>
            
            </summary>
            <remarks>Must not be virtual.</remarks>
        </member>
        <member name="M:Palaso.Progress.ProgressState.Dispose(System.Boolean)">
            <summary>
            Executes in two distinct scenarios.
            
            1. If disposing is true, the method has been called directly
            or indirectly by a user's code via the Dispose method.
            Both managed and unmanaged resources can be disposed.
            
            2. If disposing is false, the method has been called by the 
            runtime from inside the finalizer and you should not reference (access) 
            other managed objects, as they already have been garbage collected.
            Only unmanaged resources can be disposed.
            </summary>
            <param name="disposing"></param>
            <remarks>
            If any exceptions are thrown, that is fine.
            If the method is being done in a finalizer, it will be ignored.
            If it is thrown by client code calling Dispose,
            it needs to be handled by fixing the bug.
            
            If subclasses override this method, they should call the base implementation.
            </remarks>
        </member>
        <member name="P:Palaso.Progress.ProgressState.NumberOfStepsCompleted">
            <summary>
            How much the task is done
            </summary>
        </member>
        <member name="P:Palaso.Progress.ProgressState.StatusLabel">
            <summary>
            a label which describes what we are busy doing
            </summary>
        </member>
        <member name="P:Palaso.Progress.ProgressState.IsDisposed">
            <summary>
            See if the object has been disposed.
            </summary>
        </member>
        <member name="T:Palaso.Progress.InitializeProgressCallback">
            <summary>
            Delegate for a method which allows the progress range to be reset
            </summary>
        </member>
        <member name="T:Palaso.Progress.ProgressCallback">
            <summary>
            Delegate for a method which allows the progress to be updated
            </summary>
        </member>
        <member name="T:Palaso.Progress.StatusCallback">
            <summary>
            Delegate for a method which allows the status text to be updated
            </summary>
        </member>
        <member name="M:Palaso.Progress.BasicCommand.BeginInvokeCore">
            <summary>
            Implementation of the async work invoker
            </summary>
            <remarks>
            We're using the delegate BeginInvoke() / EndInvoke() pattern here
            </remarks>
        </member>
        <member name="T:Palaso.Progress.WorkInvoker">
            <summary>
            Delegate for a worker method which provides additional callbacks
            </summary>
        </member>
        <member name="M:Palaso.Progress.LogBox.LogBox.SafeInvoke(System.Windows.Forms.Control,System.Action)">
            <summary>
            This is an attempt to avoid a mysterious crash (B. Waters) where the invoke was
            happening before the window's handle had been created
            </summary>
        </member>
        <member name="F:Palaso.Progress.LogBox.LogBox.components">
            <summary> 
            Required designer variable.
            </summary>
        </member>
        <member name="M:Palaso.Progress.LogBox.LogBox.Dispose(System.Boolean)">
            <summary> 
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:Palaso.Progress.LogBox.LogBox.InitializeComponent">
            <summary> 
            Required method for Designer support - do not modify 
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="P:Palaso.Progress.LogBox.LogBox.GetDiagnosticsMethod">
            <summary>
            This is a callback the client can set to soemthing which will then generate
            Write() calls.  If it is set, the user sees a "Run diagnostics" menu item.
            </summary>
        </member>
        <member name="M:Palaso.Progress.LogBox.ConsoleProgress.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:Palaso.Progress.LogBox.LabelStatus">
            <summary>
            Just conveys status, not all messages
            </summary>
        </member>
        <member name="T:Palaso.Progress.LogBox.LogBoxResources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Palaso.Progress.LogBox.LogBoxResources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Palaso.Progress.LogBox.LogBoxResources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="T:Palaso.Progress.NullProgressState">
            <summary>
            Use this when you don't have an actual progressstate installed and don't
            want to litter the code with if(_progressState != null)'s
            </summary>
        </member>
        <member name="P:Palaso.Progress.NullProgressState.NumberOfStepsCompleted">
            <summary>
            How much the task is done
            </summary>
        </member>
        <member name="P:Palaso.Progress.NullProgressState.StatusLabel">
            <summary>
            a label which describes what we are busy doing
            </summary>
        </member>
        <member name="T:Palaso.Progress.WaitCursor">
            ----------------------------------------------------------------------------------------
        </member>
        <member name="M:Palaso.Progress.WaitCursor.Show">
            ------------------------------------------------------------------------------------
        </member>
        <member name="M:Palaso.Progress.WaitCursor.Hide">
            ------------------------------------------------------------------------------------
        </member>
        <member name="M:Palaso.Progress.WaitCursor.ToggleWaitCursorState(System.Boolean)">
            ------------------------------------------------------------------------------------
        </member>
        <!-- Badly formed XML comment ignored for member "T:Palaso.Progress.XslTransformWithProgress" -->
        <member name="T:Palaso.Progress.XslTransformWithProgress.CancelingException">
            <summary>
            used to break us out of the xslt transformer if the user cancels
            </summary>
        </member>
        <member name="T:Palaso.Properties.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Palaso.Properties.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Palaso.Properties.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="T:Palaso.Reporting.AnalyticsEventSender">
            <summary>
            For information on what's going on here, google "goolge analytics".
            </summary>
        </member>
        <member name="M:Palaso.Reporting.AnalyticsEventSender.SendEvent(System.String,System.String,System.String,System.String,System.Int32)">
            <summary>
            http://code.google.com/apis/analytics/docs/tracking/eventTrackerGuide.html
            </summary>
            <param name="category">     Videos                  Runtime</param>
            <param name="action">       Pause                   Error</param>
            <param name="optionalLabel">Gone With The Wind      Exception Message</param>
            <param name="optionalInteger">32 (that is, at 32 seconds into the video)</param>
        </member>
        <member name="M:Palaso.Reporting.AnalyticsEventSender.SendNavigationNotice(System.String,System.Object[])">
            <summary>
            Record a visit to part of the application, just as if it  were a page.
            Leave it up to this method to insert things like the fact that you are in DEBUG mode, or what version is being used, etc.
            </summary>
            <example>SendNavigationNotice("aboutBox"), SendNavigationNotice("dictionary/browseView")</example>
        </member>
        <member name="F:Palaso.Reporting.ErrorReport.s_properties">
            <summary>
            a list of name, string value pairs that will be included in the details of the error report.
            </summary>
        </member>
        <member name="M:Palaso.Reporting.ErrorReport.GetExceptionText(System.Exception)">
            ------------------------------------------------------------------------------------
            <summary>
            
            </summary>
            <param name="error"></param>
            <returns></returns>
            ------------------------------------------------------------------------------------
        </member>
        <member name="M:Palaso.Reporting.ErrorReport.AddProperty(System.String,System.String)">
            ------------------------------------------------------------------------------------
            <summary>
            add a property that he would like included in any bug reports created by this application.
            </summary>
            ------------------------------------------------------------------------------------
        </member>
        <member name="M:Palaso.Reporting.ErrorReport.GetHiearchicalExceptionInfo(System.Exception,System.Exception@)">
            ------------------------------------------------------------------------------------
            <summary>
            
            </summary>
            <returns></returns>
            ------------------------------------------------------------------------------------
        </member>
        <member name="M:Palaso.Reporting.ErrorReport.NotifyUserOfProblem(System.String,System.Object[])">
            <summary>
            Put up a message box, unless OkToInteractWithUser is false, in which case throw an Appliciation Exception.
            This will not report the problem to the developer.  Use one of the "report" methods for that.
            </summary>
        </member>
        <member name="M:Palaso.Reporting.ErrorReport.ReportNonFatalExceptionWithMessage(System.Exception,System.String,System.Object[])">
            <summary>
            Bring up a "yellow box" that let's them send in a report, then return to the program.
            </summary>
        </member>
        <member name="M:Palaso.Reporting.ErrorReport.ReportNonFatalMessageWithStackTrace(System.String,System.Object[])">
            <summary>
            Bring up a "yellow box" that let's them send in a report, then return to the program.
            Use this one only when you don't have an exception (else you're not reporting the exception's message)
            </summary>
        </member>
        <member name="M:Palaso.Reporting.ErrorReport.ReportFatalMessageWithStackTrace(System.String,System.Object[])">
            <summary>
            Bring up a "green box" that let's them send in a report, then exit.
            </summary>
        </member>
        <member name="M:Palaso.Reporting.ErrorReport.ReportNonFatalException(System.Exception)">
            <summary>
            Bring up a "yellow box" that lets them send in a report, then return to the program.
            </summary>
        </member>
        <member name="M:Palaso.Reporting.ErrorReport.ReportNonFatalException(System.Exception,Palaso.Reporting.IRepeatNoticePolicy)">
            <summary>
            Allow user to report an exception even though the program doesn't need to exit
            </summary>
        </member>
        <member name="P:Palaso.Reporting.ErrorReport.EmailAddress">
            <summary>
            set this property if you want the dialog to offer to create an e-mail message.
            </summary>
        </member>
        <member name="P:Palaso.Reporting.ErrorReport.EmailSubject">
            <summary>
            set this property if you want something other than the default e-mail subject
            </summary>
        </member>
        <member name="P:Palaso.Reporting.ErrorReport.Properties">
            <summary>
            a list of name, string value pairs that will be included in the details of the error report.
            </summary>
        </member>
        <member name="T:Palaso.Reporting.ErrorReport.NonFatalErrorReportExpected">
            <summary>
            use this in unit tests to cleanly check that a message would have been shown.
            E.g.  using (new Palaso.Reporting.ErrorReport.NonFatalErrorReportExpected()) {...}
            </summary>
        </member>
        <member name="P:Palaso.Reporting.ErrorReport.NonFatalErrorReportExpected.Message">
            <summary>
            use this to check the actual contents of the message that was triggered
            </summary>
        </member>
        <member name="T:Palaso.Reporting.ErrorReport.ProblemNotificationSentToUserException">
            <summary>
            this is for interacting with test code which doesn't want to allow an actual UI
            </summary>
        </member>
        <member name="T:Palaso.Reporting.ErrorReport.NonFatalExceptionWouldHaveBeenMessageShownToUserException">
            <summary>
            this is for interacting with test code which doesn't want to allow an actual UI
            </summary>
        </member>
        <member name="T:Palaso.Reporting.ErrorReportTests">
            <summary>
            Summary description for ErrorReportTests.
            </summary>
        </member>
        <member name="M:Palaso.Reporting.ErrorReportTests.TestSend">
            <summary>
            
            </summary>
        </member>
        <member name="M:Palaso.Reporting.ExceptionHandler.HandleUnhandledException(System.Object,System.UnhandledExceptionEventArgs)">
            ------------------------------------------------------------------------------------
            <summary>
            Catches and displays otherwise unhandled exception, especially those that happen
            during startup of the application before we show our main window.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
            ------------------------------------------------------------------------------------
        </member>
        <member name="M:Palaso.Reporting.ExceptionHandler.HandleTopLevelError(System.Object,System.Threading.ThreadExceptionEventArgs)">
            ------------------------------------------------------------------------------------
            <summary>
            Catches and displays a otherwise unhandled exception.
            </summary>
            <param name="sender">sender</param>
            <param name="eventArgs">Exception</param>
            <remarks>previously <c>AfApp::HandleTopLevelError</c></remarks>
            ------------------------------------------------------------------------------------
        </member>
        <member name="M:Palaso.Reporting.ExceptionHandler.DisplayError(System.Exception)">
            ------------------------------------------------------------------------------------
            <summary>
            Displays the error.
            </summary>
            <param name="exception">The exception.</param>
            <returns></returns>
            ------------------------------------------------------------------------------------
        </member>
        <member name="P:Palaso.Reporting.ExceptionHandler.ShowUI">
            ------------------------------------------------------------------------------------
            <summary>
            Gets the setting for displaying error message boxes. The value is retrieved from
            the .config file.
            </summary>
            <remarks>
            To disable displaying an error message box, put
            <code>&lt;add key="ShowUI" value="False"/></code>
            in the &lt;appSettings> section of the .config file (see MSDN for details).
            </remarks>
            ------------------------------------------------------------------------------------
        </member>
        <member name="T:Palaso.Reporting.ExceptionHelper">
            <summary>
            Helper class that makes it easier to get information out of nested exceptions to 
            display in the UI.
            </summary>
        </member>
        <member name="M:Palaso.Reporting.ExceptionHelper.#ctor">
            <summary>
            Not intended to be instantiated, because it contains only static methods
            </summary>
        </member>
        <member name="M:Palaso.Reporting.ExceptionHelper.GetAllExceptionMessages(System.Exception)">
            <summary>
            Get the messages from all nested exceptions
            </summary>
            <param name="e">The exception</param>
            <returns>String with the messages of all nested exceptions</returns>
        </member>
        <member name="M:Palaso.Reporting.ExceptionHelper.GetExceptionTypes(System.Exception)">
            <summary>
            Gets the exception types of all nested exceptions.
            </summary>
            <param name="e">The exception</param>
            <returns>String with the types of all nested exceptions. The string has the
            form type1(type2(type3...)).</returns>
        </member>
        <member name="M:Palaso.Reporting.ExceptionHelper.GetAllStackTraces(System.Exception)">
            <summary>
            Gets a string with the stack traces of all nested exceptions. The stack
            for the inner most exception is displayed first. Each stack is preceded
            by the exception type, module name, method name and message.
            </summary>
            <param name="e">The exception</param>
            <returns>String with stack traces of all nested exceptions.</returns>
        </member>
        <member name="M:Palaso.Reporting.ExceptionHelper.GetTargetSiteNames(System.Exception)">
            <summary>
            Gets the names of all the target sites of nested exceptions.
            </summary>
            <param name="e">The exception</param>
            <returns>String with the names of all the target sites.</returns>
        </member>
        <member name="M:Palaso.Reporting.ExceptionHelper.GetInnerMostException(System.Exception)">
            <summary>
            Gets the inner most exception
            </summary>
            <param name="e">The exception</param>
            <returns>Returns the inner most exception.</returns>
        </member>
        <member name="M:Palaso.Reporting.ExceptionHelper.GetHelpLink(System.Exception)">
            <summary>
            Gets the help string.
            </summary>
            <param name="e">The exception</param>
            <returns>The help link</returns>
        </member>
        <member name="M:Palaso.Reporting.ExceptionReportingDialog.CheckDisposed">
            <summary>
            Check to see if the object has been disposed.
            All public Properties and Methods should call this
            before doing anything else.
            </summary>
        </member>
        <member name="M:Palaso.Reporting.ExceptionReportingDialog.Dispose(System.Boolean)">
            <summary>
            Executes in two distinct scenarios.
            
            1. If disposing is true, the method has been called directly
            or indirectly by a user's code via the Dispose method.
            Both managed and unmanaged resources can be disposed.
            
            2. If disposing is false, the method has been called by the 
            runtime from inside the finalizer and you should not reference (access) 
            other managed objects, as they already have been garbage collected.
            Only unmanaged resources can be disposed.
            </summary>
            <param name="disposing"></param>
            <remarks>
            If any exceptions are thrown, that is fine.
            If the method is being done in a finalizer, it will be ignored.
            If it is thrown by client code calling Dispose,
            it needs to be handled by fixing the bug.
            
            If subclasses override this method, they should call the base implementation.
            </remarks>
        </member>
        <member name="M:Palaso.Reporting.ExceptionReportingDialog.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="M:Palaso.Reporting.ExceptionReportingDialog.ReportException(System.Exception)">
            ------------------------------------------------------------------------------------
            <summary>
            show a dialog or output to the error log, as appropriate.
            </summary>
            <param name="error">the exception you want to report</param>
            ------------------------------------------------------------------------------------
        </member>
        <member name="M:Palaso.Reporting.ExceptionReportingDialog.ReportException(System.Exception,System.Windows.Forms.Form)">
            <summary>
            
            </summary>
            <param name="error"></param>
            <param name="parent"></param>
        </member>
        <member name="M:Palaso.Reporting.ExceptionReportingDialog.ReportException(System.Exception,System.Windows.Forms.Form,System.Boolean)">
            ------------------------------------------------------------------------------------
            <summary>
            show a dialog or output to the error log, as appropriate.
            </summary>
            <param name="error">the exception you want to report</param>
            <param name="parent">the parent form that this error belongs to (i.e. the form
            show modally on)</param>
            ------------------------------------------------------------------------------------
            <param name="isLethal"></param>
        </member>
        <member name="M:Palaso.Reporting.ExceptionReportingDialog.GatherData">
            ------------------------------------------------------------------------------------
            <summary>
            
            </summary>
            ------------------------------------------------------------------------------------
        </member>
        <member name="M:Palaso.Reporting.ExceptionReportingDialog.btnClose_Click(System.Object,System.EventArgs)">
            ------------------------------------------------------------------------------------
            <summary>
            
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
            ------------------------------------------------------------------------------------
        </member>
        <member name="M:Palaso.Reporting.ExceptionReportingDialog.OnKeyDown(System.Windows.Forms.KeyEventArgs)">
            ------------------------------------------------------------------------------------
            <summary>
            Shows the attempt to continue label if the shift key is pressed
            </summary>
            <param name="e"></param>
            ------------------------------------------------------------------------------------
        </member>
        <member name="M:Palaso.Reporting.ExceptionReportingDialog.OnKeyUp(System.Windows.Forms.KeyEventArgs)">
            ------------------------------------------------------------------------------------
            <summary>
            Hides the attempt to continue label if the shift key is pressed
            </summary>
            <param name="e"></param>
            ------------------------------------------------------------------------------------
        </member>
        <member name="M:Palaso.Reporting.ILogger.WriteConciseHistoricalEvent(System.String,System.Object[])">
            <summary>
            This is something that should be listed in the source control checkin
            </summary>
        </member>
        <member name="M:Palaso.Reporting.MultiLogger.Add(Palaso.Reporting.ILogger)">
            <summary>
            NB: you must handle disposal of the logger yourself (easy with a DI container)
            </summary>
            <param name="logger"></param>
        </member>
        <member name="T:Palaso.Reporting.Logger">
            ----------------------------------------------------------------------------------------
            <summary>
            Logs stuff to a file created in 
            c:\Documents and Settings\Username\Local Settings\Temp\Companyname\Productname\Log.txt
            </summary>
            ----------------------------------------------------------------------------------------
        </member>
        <member name="M:Palaso.Reporting.Logger.Init">
            ------------------------------------------------------------------------------------
            <summary>
            Creates the logger. The logging functions can't be used until this method is 
            called.
            </summary>
            ------------------------------------------------------------------------------------
        </member>
        <member name="M:Palaso.Reporting.Logger.ShutDown">
            ------------------------------------------------------------------------------------
            <summary>
            Shut down the logger. The logging functions can't be used after this method is 
            called.
            </summary>
            ------------------------------------------------------------------------------------
        </member>
        <member name="M:Palaso.Reporting.Logger.CheckDisposed">
            <summary>
            Check to see if the object has been disposed.
            All public Properties and Methods should call this
            before doing anything else.
            </summary>
        </member>
        <member name="F:Palaso.Reporting.Logger.m_isDisposed">
            <summary>
            True, if the object has been disposed.
            </summary>
        </member>
        <member name="M:Palaso.Reporting.Logger.Finalize">
            <summary>
            Finalizer, in case client doesn't dispose it.
            Force Dispose(false) if not already called (i.e. m_isDisposed is true)
            </summary>
            <remarks>
            In case some clients forget to dispose it directly.
            </remarks>
        </member>
        <member name="M:Palaso.Reporting.Logger.WriteConciseHistoricalEvent(System.String,System.Object[])">
            <summary>
            This is for version-control checkin descriptions. E.g. "Deleted foobar".
            </summary>
            <param name="message"></param>
            <param name="args"></param>
        </member>
        <member name="M:Palaso.Reporting.Logger.Dispose">
            <summary>
            
            </summary>
            <remarks>Must not be virtual.</remarks>
        </member>
        <member name="M:Palaso.Reporting.Logger.Dispose(System.Boolean)">
            <summary>
            Executes in two distinct scenarios.
            
            1. If disposing is true, the method has been called directly
            or indirectly by a user's code via the Dispose method.
            Both managed and unmanaged resources can be disposed.
            
            2. If disposing is false, the method has been called by the 
            runtime from inside the finalizer and you should not reference (access) 
            other managed objects, as they already have been garbage collected.
            Only unmanaged resources can be disposed.
            </summary>
            <param name="disposing"></param>
            <remarks>
            If any exceptions are thrown, that is fine.
            If the method is being done in a finalizer, it will be ignored.
            If it is thrown by client code calling Dispose,
            it needs to be handled by fixing the bug.
            
            If subclasses override this method, they should call the base implementation.
            </remarks>
        </member>
        <member name="M:Palaso.Reporting.Logger.WriteEvent(System.String,System.Object[])">
            ------------------------------------------------------------------------------------
            <summary>
            Writes an event to the logger. This method will do nothing if Init() is not called
            first.
            </summary>
            <param name="message"></param>
            ------------------------------------------------------------------------------------
        </member>
        <member name="M:Palaso.Reporting.Logger.WriteMinorEvent(System.String,System.Object[])">
            <summary>
            only a limitted number of the most recent of these events will show up in the log
            </summary>
        </member>
        <member name="P:Palaso.Reporting.Logger.IsDisposed">
            <summary>
            See if the object has been disposed.
            </summary>
        </member>
        <member name="P:Palaso.Reporting.Logger.LogText">
            ------------------------------------------------------------------------------------
            <summary>
            Gets the entire text of the log file
            </summary>
            <returns></returns>
            ------------------------------------------------------------------------------------
        </member>
        <member name="M:Palaso.Reporting.ProblemNotificationDialog.#ctor(System.String,System.String)">
            <summary>
            Use this one if you need to customize the dialog, e.g. to setup an alternate button
            </summary>
            <param name="message"></param>
            <param name="dialogTitle"></param>
        </member>
        <member name="M:Palaso.Reporting.ProblemNotificationDialog.#ctor(System.String,System.String,System.Drawing.Image)">
            <summary>
            Use this one if you need to customize the dialog, e.g. to setup an alternate button
            </summary>
        </member>
        <member name="F:Palaso.Reporting.ProblemNotificationDialog.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:Palaso.Reporting.ProblemNotificationDialog.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:Palaso.Reporting.ProblemNotificationDialog.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="P:Palaso.Reporting.ReportingSettings.PreviousVersion">
            <summary>
            help notice that someone upgraded
            </summary>
        </member>
        <member name="T:Palaso.Reporting.ReportingStrings">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Palaso.Reporting.ReportingStrings.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Palaso.Reporting.ReportingStrings.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Palaso.Reporting.ReportingStrings.ks_Ok">
            <summary>
              Looks up a localized string similar to &amp;Ok.
            </summary>
        </member>
        <member name="P:Palaso.Reporting.ReportingStrings.ksPleaseEMailThisToUs">
             <summary>
               Looks up a localized string similar to Please e-mail this to {0} 
            
            {1}.
             </summary>
        </member>
        <member name="P:Palaso.Reporting.ReportingStrings.kstidFieldWorksErrorCaption">
            <summary>
              Looks up a localized string similar to Error.
            </summary>
        </member>
        <member name="P:Palaso.Reporting.ReportingStrings.kstidFieldWorksErrorExitInfo">
            <summary>
              Looks up a localized string similar to This application must exit..
            </summary>
        </member>
        <member name="T:Palaso.Reporting.UsageEmailDialog">
            <summary>
            Summary description for UsageEmailDialog.
            </summary>
        </member>
        <member name="F:Palaso.Reporting.UsageEmailDialog.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:Palaso.Reporting.UsageEmailDialog.CheckDisposed">
            <summary>
            Check to see if the object has been disposed.
            All public Properties and Methods should call this
            before doing anything else.
            </summary>
        </member>
        <member name="M:Palaso.Reporting.UsageEmailDialog.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
        </member>
        <member name="M:Palaso.Reporting.UsageEmailDialog.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="P:Palaso.Reporting.UsageEmailDialog.TopLineText">
            <summary>
            
            </summary>
        </member>
        <member name="M:Palaso.Reporting.UsageReporter.Init(Palaso.Reporting.ReportingSettings,System.String,System.String,System.Boolean)">
             <summary>
             
             </summary>
             <example>
             UsageReporter.Init(Settings.Default.Reporting, "myproduct.org", "UA-11111111-2",
            #if DEBUG
                            true
            #else
                            false
            #endif
                            );
             </example>
             <param name="settings"></param>
             <param name="domain"></param>
             <param name="googleAnalyticsAccountCode"></param>
             <param name="reportAsDeveloper">Normally this is true for DEBUG builds. It is separated out here because sometimes a developer
             uses a Release build of Palaso.dll, but would still want his/her activities logged as a developer.</param>
        </member>
        <member name="M:Palaso.Reporting.UsageReporter.MakeLaunchDateSafe">
            <summary>
            cover an apparent bug in the generated code when you do a get but the datetime is null
            </summary>
        </member>
        <member name="M:Palaso.Reporting.UsageReporter.ResetSettingsForTests">
            <summary>
            used for testing purposes
            </summary>
        </member>
        <member name="M:Palaso.Reporting.UsageReporter.GetAllApplicationValuesForThisUser">
            <summary>
            store and retrieve values which are the same for all apps using this usage libary
            </summary>
            <returns></returns>
        </member>
        <member name="M:Palaso.Reporting.UsageReporter.BeginGoogleAnalytics(System.String,System.String,System.Boolean)">
            <summary>
             Reports upgrades, launches, etc., and allows for later calls to notify analytics of navigation and events
            </summary>
        </member>
        <member name="M:Palaso.Reporting.UsageReporter.SendNavigationNotice(System.String,System.Object[])">
            <summary>
            Send an navigation notice to Google Analytics, if BeginGoogleAnalytics was previously called
            Record a visit to part of the application, just as if it  were a page.
            Leave it up to this method to insert things like the fact that you are in DEBUG mode, or what version is being used, etc.
            </summary>
            <example>SendNavigationNotice("aboutBox"), SendNavigationNotice("dictionary/browseView")</example>
        </member>
        <member name="M:Palaso.Reporting.UsageReporter.SendEvent(System.String,System.String,System.String,System.String,System.Int32)">
            <summary>
            Send an event to Google Analytics, if BeginGoogleAnalytics was previously called
            </summary>
            <param name="programArea">DictionaryBrowse</param>
            <param name="action">       DeleteWord                   Error</param>
            <param name="optionalLabel">Some Exception Message</param>
            <param name="optionalInteger">some integer that makes sense for this event</param>
            <example>SendEvent("dictionary/browseView", "Command", "DeleteWord", "","")</example>
            <example>SendEvent("dictionary/browseView", "Error", "DeleteWord", "some error message we got","")</example>
        </member>
        <member name="M:Palaso.Reporting.UsageReporter.ReportException(System.Boolean,System.String,System.Exception)">
            <summary>
            Send an error to Google Analytics, if BeginGoogleAnalytics was previously called
            </summary>
        </member>
        <member name="P:Palaso.Reporting.UsageReporter.UserGuid">
            <summary>
            A unique guid for this machine, which is the same for all palaso apps (because we store it in special palaso text file in appdata)
            </summary>
        </member>
        <member name="P:Palaso.Reporting.UsageReporter.AppNameToUseInDialogs">
            <summary>
            The deal here is, Cambell changed this so that it is the responsibility of
            the client to set this, and then save the settings.
            E.g., in the Settings.Designer.cs, add
            
                [UserScopedSetting()]
            	[DebuggerNonUserCode()]
            	public Palaso.Reporting.ReportingSettings Reporting
            	{
            		get { return ((Palaso.Reporting.ReportingSettings)(this["Reporting"])); }
            		set { this["Reporting"] = value; }
            	}
            </summary>
        </member>
        <member name="F:Palaso.Reporting.UserRegistrationDialog.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:Palaso.Reporting.UserRegistrationDialog.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:Palaso.Reporting.UserRegistrationDialog.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:Palaso.Resource">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Palaso.Resource.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Palaso.Resource.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Palaso.Resource.languageCodes">
             <summary>
               Looks up a localized string similar to Id	Part2B	Part2T	Part1	Scope	Type	Ref_Name
            aaa				I	L	Ghotuo
            aab				I	L	Alumu-Tesu
            aac				I	L	Ari
            aad				I	L	Amal
            aae				I	L	Arbëreshë Albanian
            aaf				I	L	Aranadan
            aag				I	L	Ambrak
            aai				I	L	Arifama-Miniafia
            aak				I	L	Ankave
            aal				I	L	Afade
            aam				I	L	Aramanik
            aan				I	L	Anambé
            aao				I	L	Algerian Saharan Arabic
            aap				I	L	Pará Arára
            aaq				I	E	Eastern Abnaki
            aar	aar	aar	aa	I	L	Afar
            aas				I	L	Aasáx
            aat				I	L	Arvanitika Albanian
            aau				I	L	Abau
            aaw				I	L	Solong
            aax				I	L	Mandobo  [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:Palaso.Resource.scriptNames">
             <summary>
               Looks up a localized string similar to #
            # Language 15924 - Codes for the representation of names of scripts
            #             Codes pour la représentation des noms d’écritures
            # Format: 
            #             Code;N°;English Name;Nom français;PVA;Date
            #
            
            Arab;160;Arabic;arabe;Arabic;2004-05-01
            Armn;230;Armenian;arménien;Armenian;2004-05-01
            Avst;134;Avestan;avestique;;2007-07-15
            Bali;360;Balinese;balinais;Balinese;2006-10-10
            Batk;365;Batak;batak;;2004-05-01
            Beng;325;Bengali;bengalî;Bengali;2004-05-01
            Blis;550;Blissymbols;symboles Bliss;;2004-05-01
             [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:Palaso.Resource.IanaSubtags">
             <summary>
               Looks up language subtags
            
             Type: language
            Subtag: aa
            Description: Afar
            Added: 2005-10-16
            %%
            Type: language
            Subtag: ab
            Description: Abkhazian
            Added: 2005-10-16
            Suppress-Script: Cyrl
            %%
            Type: language
            Subtag: ae
            Description: Avestan
            Added: 2005-10-16
            %%
             </summary>
        </member>
        <member name="P:Palaso.Resource.TwoToThreeCodes">
            <summary>
              Looks up file containing mappings from two to (old) three letter codes
            </summary>
        </member>
        <member name="M:Palaso.IO.SFMReader.#ctor(System.String)">
            <summary>
            Construct a new SFMReader with filename
            </summary>
            <param name="fname"></param>
        </member>
        <member name="M:Palaso.IO.SFMReader.#ctor(System.IO.Stream)">
            <summary>
            Construct a new SFMReader with stream
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:Palaso.IO.SFMReader.ReadNextTag">
            <summary>
            Read next tag and return the name only (exclude backslash
            and space).
            </summary>
            <returns>next tag name</returns>
        </member>
        <member name="M:Palaso.IO.SFMReader.ReadNextText">
            <summary>
            Read next text block from stream
            </summary>
            <returns>Next text</returns>
        </member>
        <member name="T:Spart.Actions.ActionEventArgs">
            <summary>
            Action event argument class
            </summary>
        </member>
        <member name="M:Spart.Actions.ActionEventArgs.#ctor(Spart.Parsers.ParserMatch)">
            <summary>
            Construct a new event argument instance
            </summary>
            <param name="match"></param>
        </member>
        <member name="M:Spart.Actions.ActionEventArgs.#ctor(Spart.Parsers.ParserMatch,System.Object)">
            <summary>
            Construct a new event argument instance
            </summary>
            <param name="match"></param>
            <param name="typedValue"></param>
        </member>
        <member name="P:Spart.Actions.ActionEventArgs.Match">
            <summary>
            The parser match
            </summary>
        </member>
        <member name="P:Spart.Actions.ActionEventArgs.Value">
            <summary>
            The parser match value
            </summary>
        </member>
        <member name="P:Spart.Actions.ActionEventArgs.TypeValue">
            <summary>
            The typed parse result
            </summary>
        </member>
        <member name="T:Spart.Actions.ActionHandler">
            <summary>
            Action handler delegate
            </summary>
        </member>
        <member name="T:Spart.Actions.ActionHandlers">
            <summary>
            Static helper class that creates actors
            </summary>
        </member>
        <member name="M:Spart.Actions.ActionHandlers.Append(System.Collections.IList)">
            <summary>
            Create an actor that append the parse result to a <see cref="T:System.Collections.IList"/>.
            </summary>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:Spart.Actions.ActionHandlers.Throw(System.Exception)">
            <summary>
            Creates an actor that throws an exception
            </summary>
            <param name="ex"></param>
            <returns></returns>
        </member>
        <member name="T:Spart.Debug.DebugContext">
            <summary>
            A Debug Context
            </summary>
        </member>
        <member name="T:Spart.Parsers.NonTerminal.IParserContext">
            <summary>
            a parser context
            </summary>
        </member>
        <member name="M:Spart.Parsers.NonTerminal.IParserContext.PreParse(System.Object,Spart.Parsers.NonTerminal.PreParseEventArgs)">
            <summary>
            handle the preparse event
            </summary>
            <param name="sender"></param>
            <param name="args"></param>
        </member>
        <member name="M:Spart.Parsers.NonTerminal.IParserContext.PostParse(System.Object,Spart.Parsers.NonTerminal.PostParseEventArgs)">
            <summary>
            handle the postparse event
            </summary>
            <param name="sender"></param>
            <param name="args"></param>
        </member>
        <member name="M:Spart.Debug.DebugContext.#ctor(System.IO.TextWriter)">
            <summary>
            constructor
            </summary>
            <param name="output"></param>
        </member>
        <member name="M:Spart.Debug.DebugContext.PreParse(System.Object,Spart.Parsers.NonTerminal.PreParseEventArgs)">
            <summary>
            handle the preparse event
            </summary>
            <param name="sender"></param>
            <param name="args"></param>
        </member>
        <member name="M:Spart.Debug.DebugContext.PostParse(System.Object,Spart.Parsers.NonTerminal.PostParseEventArgs)">
            <summary>
            handle the postparse event
            </summary>
            <param name="sender"></param>
            <param name="args"></param>
        </member>
        <member name="P:Spart.Debug.DebugContext.Output">
            <summary>
            The output Text Writer
            </summary>
        </member>
        <member name="P:Spart.Debug.DebugContext.Tab">
            <summary>
            A string with the current indentation suitable for prepending to output that should be nested
            </summary>
        </member>
        <member name="T:Spart.Debug.Debugger">
            <summary>
            A Debugger
            </summary>
        </member>
        <member name="M:Spart.Debug.Debugger.#ctor(Spart.Parsers.NonTerminal.IParserContext)">
            <summary>
            constructor
            </summary>
            <param name="context"></param>
        </member>
        <member name="M:Spart.Debug.Debugger.#ctor(System.IO.TextWriter)">
            <summary>
            constructor
            </summary>
            <param name="output"></param>
        </member>
        <member name="M:Spart.Debug.Debugger.op_Addition(Spart.Debug.Debugger,Spart.Parsers.NonTerminal.Rule)">
            <summary>
            Adds the debug context to the given rule
            </summary>
            <param name="debug"></param>
            <param name="rule"></param>
            <returns></returns>
        </member>
        <member name="P:Spart.Debug.Debugger.Context">
            <summary>
            The current parser context
            </summary>
        </member>
        <member name="T:Spart.Parsers.BinaryTerminalParser">
            <summary>
            A Parser with two terminals (which may be parsers themselves)
            </summary>
        </member>
        <member name="T:Spart.Parsers.TerminalParser">
            <summary>
            abstract class Terminal Parser
            </summary>
        </member>
        <member name="T:Spart.Parsers.Parser">
            <summary>
            Abstract parser class
            </summary>
        </member>
        <member name="M:Spart.Parsers.Parser.ParseMain(Spart.Scanners.IScanner)">
            <summary>
            Inner parse method
            </summary>
            <param name="scanner">scanner</param>
            <returns>the match</returns>
        </member>
        <member name="M:Spart.Parsers.Parser.Parse(Spart.Scanners.IScanner)">
            <summary>
            Outer parse method (consumes input)
            </summary>
            <param name="scanner"></param>
            <returns></returns>
        </member>
        <member name="M:Spart.Parsers.Parser.TryAccept(Spart.Scanners.IScanner)">
            <summary>
            Lookahead to determine if parser can be used to parse (does not consume input)
            </summary>
            <param name="scanner"></param>
            <returns></returns>
        </member>
        <member name="M:Spart.Parsers.Parser.OnAction(Spart.Parsers.ParserMatch)">
            <summary>
            Action caller method
            </summary>
            <param name="m"></param>
        </member>
        <member name="M:Spart.Parsers.Parser.op_UnaryPlus(Spart.Parsers.Parser)">
            <summary>
            Unary repeatable operator
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:Spart.Parsers.Parser.op_LogicalNot(Spart.Parsers.Parser)">
            <summary>
            Unary Optional operator
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:Spart.Parsers.Parser.op_BitwiseOr(Spart.Parsers.Parser,Spart.Parsers.Parser)">
            <summary>
            Binary Alternative operator
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Spart.Parsers.Parser.op_BitwiseAnd(Spart.Parsers.Parser,Spart.Parsers.Parser)">
            <summary>
            Binary Intersection operator
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Spart.Parsers.Parser.op_Subtraction(Spart.Parsers.Parser,Spart.Parsers.Parser)">
            <summary>
            Binary Difference operator
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Spart.Parsers.Parser.op_Modulus(Spart.Parsers.Parser,Spart.Parsers.Parser)">
            <summary>
            Binary List operator
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Spart.Parsers.Parser.op_Implicit(System.Char)~Spart.Parsers.Parser">
            <summary>
            Cast operator, creates a Parser that recognizes the given char
            </summary>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:Spart.Parsers.Parser.op_Implicit(System.String)~Spart.Parsers.Parser">
            <summary>
            Cast operator, creates a Parser that recognizes the given string
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="E:Spart.Parsers.Parser.Act">
            <summary>
            Action event
            </summary>
        </member>
        <member name="P:Spart.Parsers.Parser.Item(Spart.Actions.ActionHandler)">
            <summary>
            Applies the given action handler to this parser
            </summary>
            <param name="act">An ActionHandler</param>
            <returns>this</returns>
        </member>
        <member name="M:Spart.Parsers.BinaryTerminalParser.#ctor(Spart.Parsers.Parser,Spart.Parsers.Parser)">
            <summary>
            constructor
            </summary>
            <param name="first"></param>
            <param name="second"></param>
        </member>
        <member name="P:Spart.Parsers.BinaryTerminalParser.FirstParser">
            <summary>
            Access or change the first parser
            </summary>
        </member>
        <member name="P:Spart.Parsers.BinaryTerminalParser.SecondParser">
            <summary>
            Access or change the second parser
            </summary>
        </member>
        <member name="T:Spart.Parsers.Composite.AlternativeParser">
            <summary>
            Matches if one of the given parsers matches (union)
            </summary>
        </member>
        <member name="M:Spart.Parsers.Composite.AlternativeParser.#ctor(Spart.Parsers.Parser,Spart.Parsers.Parser)">
            <summary>
            constructor
            </summary>
            <param name="first">one alternative</param>
            <param name="second">another alternative</param>
        </member>
        <member name="M:Spart.Parsers.Composite.AlternativeParser.ParseMain(Spart.Scanners.IScanner)">
            <summary>
            Inner parse method
            </summary>
            <param name="scanner">scanner</param>
            <returns>the match</returns>
        </member>
        <member name="T:Spart.Parsers.Composite.DifferenceParser">
            <summary>
            Match first but not second. If both match and the matched text of the second is 
            shorter than the matched text of the first, a successful match is made
            </summary>
        </member>
        <member name="M:Spart.Parsers.Composite.DifferenceParser.#ctor(Spart.Parsers.Parser,Spart.Parsers.Parser)">
            <summary>
            constructor
            </summary>
            <param name="left">match left</param>
            <param name="right">don't match right</param>
        </member>
        <member name="M:Spart.Parsers.Composite.DifferenceParser.ParseMain(Spart.Scanners.IScanner)">
            <summary>
            Inner parse method
            </summary>
            <param name="scanner">scanner</param>
            <returns>the match</returns>
        </member>
        <member name="T:Spart.Parsers.Composite.IntersectionParser">
            <summary>
            A parser which matches when the input matches the first parser and the second parser
            </summary>
        </member>
        <member name="M:Spart.Parsers.Composite.IntersectionParser.#ctor(Spart.Parsers.Parser,Spart.Parsers.Parser)">
            <summary>
            constructor
            </summary>
            <param name="first"></param>
            <param name="second"></param>
        </member>
        <member name="M:Spart.Parsers.Composite.IntersectionParser.ParseMain(Spart.Scanners.IScanner)">
            <summary>
            Inner parse method
            </summary>
            <param name="scanner">scanner</param>
            <returns>the match</returns>
        </member>
        <member name="T:Spart.Parsers.Composite.ListParser">
            <summary>
            recognize a list of one or more repetitions of first parser seperated by occurrences of 
            the second parser (the delimiter). This is equivalent to:
            Sequence(first, ZeroOrMore(Sequence(second, first))
            a must not also match b!
            </summary>
        </member>
        <member name="M:Spart.Parsers.Composite.ListParser.#ctor(Spart.Parsers.Parser,Spart.Parsers.Parser)">
            <summary>
            constructs a list parser that recognizes items separated by a delimiter
            </summary>
            <param name="first">item</param>
            <param name="second">delimiter</param>
        </member>
        <member name="M:Spart.Parsers.Composite.ListParser.ParseMain(Spart.Scanners.IScanner)">
            <summary>
            Inner parse method
            </summary>
            <param name="scanner">scanner</param>
            <returns>the match</returns>
        </member>
        <member name="T:Spart.Parsers.Composite.RepetitionParser">
            <summary>
            matches a given range of count of the given parser
            </summary>
        </member>
        <member name="T:Spart.Parsers.UnaryTerminalParser">
            <summary>
            abstract unary parser
            </summary>
        </member>
        <member name="M:Spart.Parsers.UnaryTerminalParser.#ctor(Spart.Parsers.Parser)">
            <summary>
            constructor
            </summary>
            <param name="parser"></param>
        </member>
        <member name="P:Spart.Parsers.UnaryTerminalParser.Parser">
            <summary>
            The associated parser
            </summary>
        </member>
        <member name="M:Spart.Parsers.Composite.RepetitionParser.#ctor(Spart.Parsers.Parser,System.Int32,System.Int32)">
            <summary>
            constructor
            </summary>
            <param name="parser">the parser to match</param>
            <param name="lowerBound">the least number of valid occurrences</param>
            <param name="upperBound">the most number of valid occurrences</param>
        </member>
        <member name="M:Spart.Parsers.Composite.RepetitionParser.SetBounds(System.Int32,System.Int32)">
            <summary>
            set the range of the amount of occurrences of the parser allowed
            </summary>
            <param name="lower_bound">the least amount of occurrences allowed</param>
            <param name="upper_bound">the most amount of occurrences allowed</param>
        </member>
        <member name="M:Spart.Parsers.Composite.RepetitionParser.ParseMain(Spart.Scanners.IScanner)">
            <summary>
            Inner parse method
            </summary>
            <param name="scanner">scanner</param>
            <returns>the match</returns>
        </member>
        <member name="P:Spart.Parsers.Composite.RepetitionParser.LowerBound">
            <summary>
            the least amount of occurrences of the parser allowed
            </summary>
        </member>
        <member name="P:Spart.Parsers.Composite.RepetitionParser.UpperBound">
            <summary>
            the most amount of occurrences of the parser allowed
            </summary>
        </member>
        <member name="T:Spart.Parsers.Composite.SequenceParser">
            <summary>
            matches a sequence of parsers
            </summary>
        </member>
        <member name="M:Spart.Parsers.Composite.SequenceParser.#ctor(Spart.Parsers.Parser,Spart.Parsers.Parser)">
            <summary>
            constructor
            </summary>
            <param name="first">the first parser to match</param>
            <param name="second">the next parser to match</param>
        </member>
        <member name="M:Spart.Parsers.Composite.SequenceParser.ParseMain(Spart.Scanners.IScanner)">
            <summary>
            Inner parse method
            </summary>
            <param name="scanner">scanner</param>
            <returns>the match</returns>
        </member>
        <member name="T:Spart.Parsers.Composite.XorParser">
            <summary>
            Recognizes anything which is found in the first parser or the second, but not both
            </summary>
        </member>
        <member name="M:Spart.Parsers.Composite.XorParser.#ctor(Spart.Parsers.Parser,Spart.Parsers.Parser)">
            <summary>
            constructor
            </summary>
            <param name="left">match left</param>
            <param name="right">don't match right</param>
        </member>
        <member name="M:Spart.Parsers.Composite.XorParser.ParseMain(Spart.Scanners.IScanner)">
            <summary>
            Inner parse method
            match (first but not second) or (second but not first)
            </summary>
            <param name="scanner">scanner</param>
            <returns>the match</returns>
        </member>
        <member name="T:Spart.Parsers.NegatableParser">
            <summary>
            A parser that can be negated (will match anything that it would not have matched and won't match anything it would have matched)
            </summary>
        </member>
        <member name="M:Spart.Parsers.NegatableParser.op_OnesComplement(Spart.Parsers.NegatableParser)">
            <summary>
            Negate this parser
            </summary>
            <param name="p">the parser to negate</param>
            <returns></returns>
        </member>
        <member name="P:Spart.Parsers.NegatableParser.Negate">
            <summary>
            Should this parser be negated
            </summary>
        </member>
        <member name="T:Spart.Parsers.NonTerminal.AssertiveParser">
            <summary>
            An AssertiveParser is a parser holder that throws an exception
                 in response to a parsing failure.
            </summary>
            <remarks>The parsing failure is determined by the AssertDelegate which defaults
            to asserting on match failure.</remarks>
        </member>
        <member name="T:Spart.Parsers.NonTerminal.NonTerminalParser">
            <summary>
            NonTerminal parser abstract class
            </summary>
        </member>
        <member name="M:Spart.Parsers.NonTerminal.NonTerminalParser.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Spart.Parsers.NonTerminal.NonTerminalParser.OnPreParse(Spart.Scanners.IScanner)">
            <summary>
            Preparse event caller
            </summary>
            <param name="scan"></param>
        </member>
        <member name="M:Spart.Parsers.NonTerminal.NonTerminalParser.OnPostParse(Spart.Parsers.ParserMatch,Spart.Scanners.IScanner)">
            <summary>
            Post parse event caller
            </summary>
            <param name="match"></param>
            <param name="scan"></param>
        </member>
        <member name="M:Spart.Parsers.NonTerminal.NonTerminalParser.AddContext(Spart.Parsers.NonTerminal.IParserContext)">
            <summary>
            Adds event handlers
            </summary>
            <param name="context"></param>
        </member>
        <member name="M:Spart.Parsers.NonTerminal.NonTerminalParser.RemoveContext(Spart.Parsers.NonTerminal.IParserContext)">
            <summary>
            Removes event handlers
            </summary>
            <param name="context"></param>
        </member>
        <member name="P:Spart.Parsers.NonTerminal.NonTerminalParser.ID">
            <summary>
            Rule ID, used for debugging
            </summary>
        </member>
        <member name="E:Spart.Parsers.NonTerminal.NonTerminalParser.PreParse">
            <summary>
            Pre parse event
            </summary>
        </member>
        <member name="E:Spart.Parsers.NonTerminal.NonTerminalParser.PostParse">
            <summary>
            Post parse event 
            </summary>
        </member>
        <member name="P:Spart.Parsers.NonTerminal.AssertiveParser.Parser">
            <summary>
            Wrapped parser
            </summary>
        </member>
        <member name="P:Spart.Parsers.NonTerminal.AssertiveParser.Assert">
            <summary>
            validator
            </summary>
        </member>
        <member name="T:Spart.Parsers.NonTerminal.PostParseEventArgs">
            <summary>
            Arguments associated with the PostParse event
            </summary>
        </member>
        <member name="M:Spart.Parsers.NonTerminal.PostParseEventArgs.#ctor(Spart.Parsers.ParserMatch,Spart.Parsers.NonTerminal.NonTerminalParser,Spart.Scanners.IScanner)">
            <summary>
            Constructs a post parse event args
            </summary>
            <param name="match"></param>
            <param name="parser"></param>
            <param name="scanner"></param>
        </member>
        <member name="P:Spart.Parsers.NonTerminal.PostParseEventArgs.Match">
            <summary>
            The associated match
            </summary>
        </member>
        <member name="P:Spart.Parsers.NonTerminal.PostParseEventArgs.Parser">
            <summary>
            The current parser
            </summary>
        </member>
        <member name="P:Spart.Parsers.NonTerminal.PostParseEventArgs.Scanner">
            <summary>
            the current scanner
            </summary>
        </member>
        <member name="T:Spart.Parsers.NonTerminal.PostParseEventHandler">
            <summary>
            Delegate for handling PostParse Events
            </summary>
            <param name="sender"></param>
            <param name="args"></param>
        </member>
        <member name="T:Spart.Parsers.NonTerminal.PreParseEventArgs">
            <summary>
            Summary description for PostParseEventArgs.
            </summary>
        </member>
        <member name="M:Spart.Parsers.NonTerminal.PreParseEventArgs.#ctor(Spart.Parsers.NonTerminal.NonTerminalParser,Spart.Scanners.IScanner)">
            <summary>
            construct a preparse event args from parser and scanner
            </summary>
            <param name="parser"></param>
            <param name="scanner"></param>
        </member>
        <member name="P:Spart.Parsers.NonTerminal.PreParseEventArgs.Parser">
            <summary>
            Current parser
            </summary>
        </member>
        <member name="P:Spart.Parsers.NonTerminal.PreParseEventArgs.Scanner">
            <summary>
            current scanner
            </summary>
        </member>
        <member name="T:Spart.Parsers.NonTerminal.PreParseEventHandler">
            <summary>
            Handle pre parse events
            </summary>
            <param name="sender"></param>
            <param name="args"></param>
        </member>
        <member name="T:Spart.Parsers.NonTerminal.Rule">
            <summary>
            A rule is a parser holder.
            </summary>
        </member>
        <member name="M:Spart.Parsers.NonTerminal.Rule.#ctor">
            <summary>
            Empty rule creator
            </summary>
        </member>
        <member name="M:Spart.Parsers.NonTerminal.Rule.#ctor(System.String)">
            <summary>
            Constructs a rule with an id (used for debugging)
            </summary>
            <param name="id">rule id (used for debugging)</param>
        </member>
        <member name="M:Spart.Parsers.NonTerminal.Rule.#ctor(Spart.Parsers.Parser)">
            <summary>
            Creates a rule and assign parser
            </summary>
            <param name="p"></param>
        </member>
        <member name="M:Spart.Parsers.NonTerminal.Rule.#ctor(System.String,Spart.Parsers.Parser)">
            <summary>
            Creates a rule with an idand assign parser
            </summary>
            <param name="p"></param>
            <param name="id">rule id (used for debugging)</param>
        </member>
        <member name="M:Spart.Parsers.NonTerminal.Rule.ParseMain(Spart.Scanners.IScanner)">
            <summary>
            Inner parse method
            </summary>
            <param name="scanner"></param>
            <returns></returns>
        </member>
        <member name="P:Spart.Parsers.NonTerminal.Rule.Parser">
            <summary>
            Rule parser
            </summary>
        </member>
        <member name="P:Spart.Parsers.NonTerminal.Rule.Item(Spart.Actions.ActionHandler)">
            <summary>
            Applies the given action handler to this parser
            </summary>
            <remarks>
            This is syntactic sugar to allow Rules to use shorthand and not require a cast
            </remarks>
            <param name="act">An ActionHandler</param>
            <returns>this</returns>
        </member>
        <member name="T:Spart.Parsers.Ops">
            <summary>
            Static helper class to create new parser operators
            </summary>
        </member>
        <member name="M:Spart.Parsers.Ops.Sequence(Spart.Parsers.Parser[])">
            <summary>
            &gt;&gt; operator
            </summary>
            <param name="args">A list of parsers</param>
            <returns>A sequence parser</returns>
        </member>
        <member name="M:Spart.Parsers.Ops.Choice(Spart.Parsers.Parser[])">
            <summary>
            | operator
            </summary>
            <param name="args">a list of the parsers to alternate between</param>
            <returns></returns>
        </member>
        <member name="M:Spart.Parsers.Ops.Intersection(Spart.Parsers.Parser[])">
            <summary>
            &amp; operator
            </summary>
            <param name="args">a list of the parsers to intersect</param>
            <returns></returns>
        </member>
        <member name="M:Spart.Parsers.Ops.Difference(Spart.Parsers.Parser,Spart.Parsers.Parser)">
            <summary>
            - operator
            </summary>
            <param name="first">A parser to recognize</param>
            <param name="second">A parser to not recognize</param>
            <returns></returns>
        </member>
        <member name="M:Spart.Parsers.Ops.List(Spart.Parsers.Parser,Spart.Parsers.Parser)">
            <summary>
            % operator
            </summary>
            <param name="first">A parser that recognizes the item(s)</param>
            <param name="second">A parser that recognizes the delimiter</param>
            <returns></returns>
        </member>
        <member name="M:Spart.Parsers.Ops.ZeroOrMore(Spart.Parsers.Parser)">
            <summary>
            * operators
            </summary>
            <param name="parser"></param>
            <returns></returns>
        </member>
        <member name="M:Spart.Parsers.Ops.OneOrMore(Spart.Parsers.Parser)">
            <summary>
            + operator
            </summary>
            <param name="parser"></param>
            <returns></returns>
        </member>
        <member name="M:Spart.Parsers.Ops.Optional(Spart.Parsers.Parser)">
            <summary>
            ! operator
            </summary>
            <param name="parser"></param>
            <returns></returns>
        </member>
        <member name="T:Spart.Parsers.ParserMatch">
            <summary>
            A parser match
            </summary>
        </member>
        <member name="M:Spart.Parsers.ParserMatch.CreateSuccessfulMatch(Spart.Scanners.IScanner,System.Int64,System.Int32)">
            <summary>
            Builds a new successful match
            </summary>
            <param name="scanner">The scanner used while matching</param>
            <param name="startOffset">The position at which the match started</param>
            <param name="length">The lenthg of the stream successfully matched</param>
        </member>
        <member name="M:Spart.Parsers.ParserMatch.CreateSuccessfulMatch(Spart.Scanners.IScanner,System.Int64,System.Int64)">
            <summary>
            Builds a new successful match ending at the current position of the scanner
            </summary>
            <param name="scanner">The scanner used while matching</param>
            <param name="startOffset">The position at which the match started</param>
            <param name="endOffset">The position at which the match ends</param>
        </member>
        <member name="M:Spart.Parsers.ParserMatch.CreateSuccessfulMatch(Spart.Scanners.IScanner,System.Int64)">
            <summary>
            Builds a new successful match ending at the current position of the scanner
            </summary>
            <param name="scanner">The scanner used while matching</param>
            <param name="startOffset">The position at which the match started</param>
        </member>
        <member name="M:Spart.Parsers.ParserMatch.CreateSuccessfulEmptyMatch(Spart.Scanners.IScanner,System.Int64)">
            <summary>
            Builds a new successful empty match
            </summary>
            <param name="scanner">The scanner used while matching</param>
            <param name="offset">The position at which the match started</param>
        </member>
        <member name="M:Spart.Parsers.ParserMatch.CreateSuccessfulEmptyMatch(Spart.Scanners.IScanner)">
            <summary>
            Builds a new successful empty match at the current position of the scanner
            </summary>
            <param name="scanner">The scanner used while matching</param>
        </member>
        <member name="M:Spart.Parsers.ParserMatch.CreateFailureMatch(Spart.Scanners.IScanner,System.Int64,System.Int32)">
            <summary>
            Create a failure match
            </summary>
            <param name="scanner">The scanner used while matching</param>
            <param name="startOffset">The position at which the match started</param>
            <param name="length">The end of the stream successfully matched</param>
        </member>
        <member name="M:Spart.Parsers.ParserMatch.CreateFailureMatch(Spart.Scanners.IScanner,System.Int64,System.Int64)">
            <summary>
            Create a failure match
            </summary>
            <param name="scanner">The scanner used while matching</param>
            <param name="startOffset">The position at which the match started</param>
            <param name="endOffset">The position of the end of the stream successfully matched before failure</param>
        </member>
        <member name="M:Spart.Parsers.ParserMatch.CreateFailureMatch(Spart.Scanners.IScanner,System.Int64)">
            <summary>
            Create a failure match ending at the current position of the scanner
            </summary>
            <param name="scanner">The scanner used while matching</param>
            <param name="startOffset">The position at which the match started</param>
        </member>
        <member name="M:Spart.Parsers.ParserMatch.CreateFailureMatch(Spart.Scanners.IScanner)">
            <summary>
            Create a failure match beginning and ending at the current position of the scanner
            </summary>
            <param name="scanner">The scanner used while matching</param>
        </member>
        <member name="M:Spart.Parsers.ParserMatch.Concat(Spart.Parsers.ParserMatch)">
            <summary>
            Concatenates match with m
            </summary>
            <param name="m"></param>
        </member>
        <member name="P:Spart.Parsers.ParserMatch.Scanner">
            <summary>
            Scanner
            </summary>
        </member>
        <member name="P:Spart.Parsers.ParserMatch.Offset">
            <summary>
            Offset
            </summary>
        </member>
        <member name="P:Spart.Parsers.ParserMatch.Length">
            <summary>
            Length
            </summary>
        </member>
        <member name="P:Spart.Parsers.ParserMatch.Value">
            <summary>
            Extracts the match value
            </summary>
        </member>
        <member name="P:Spart.Parsers.ParserMatch.Success">
            <summary>
            True if match successfull
            </summary>
        </member>
        <member name="P:Spart.Parsers.ParserMatch.Empty">
            <summary>
            True if match empty
            </summary>
        </member>
        <member name="T:Spart.Parsers.Primitives.CharParser">
            <summary>
            Matches any character that the given character recognizer recognizes
            </summary>
        </member>
        <member name="M:Spart.Parsers.Primitives.CharParser.#ctor(Spart.Parsers.Primitives.Testers.CharRecognizer)">
            <summary>
            constructor
            </summary>
            <param name="tester">The character recognizer to use to match</param>
        </member>
        <member name="M:Spart.Parsers.Primitives.CharParser.ParseMain(Spart.Scanners.IScanner)">
            <summary>
            Inner parse method
            </summary>
            <param name="scanner">scanner</param>
            <returns>the match</returns>
        </member>
        <member name="P:Spart.Parsers.Primitives.CharParser.Accepts">
            <summary>
            Character tester to use to determine if we have a match
            </summary>
        </member>
        <member name="T:Spart.Parsers.Primitives.Testers.CharRecognizer">
            <summary>
            A Delegate for testing whether a character should be recognized
            </summary>
            <param name="c">The character to be tested</param>
            <returns>true when the character is recognized, false when it is not</returns>
        </member>
        <member name="T:Spart.Parsers.Primitives.EndParser">
            <summary>
            Matches the eof
            </summary>
        </member>
        <member name="M:Spart.Parsers.Primitives.EndParser.ParseMain(Spart.Scanners.IScanner)">
            <summary>
            Inner parse method
            </summary>
            <param name="scanner">scanner</param>
            <returns>the match</returns>
        </member>
        <member name="T:Spart.Parsers.Primitives.EolParser">
            <summary>
            Matches a CR, LF, or CR LF
            </summary>
        </member>
        <member name="M:Spart.Parsers.Primitives.EolParser.ParseMain(Spart.Scanners.IScanner)">
            <summary>
            Inner parse method
            </summary>
            <param name="scanner">scanner</param>
            <returns>the match</returns>
        </member>
        <member name="T:Spart.Parsers.Primitives.NothingParser">
            <summary>
            Recognizes nothing (always returns no match)
            </summary>
        </member>
        <member name="M:Spart.Parsers.Primitives.NothingParser.ParseMain(Spart.Scanners.IScanner)">
            <summary>
            Inner parse method
            </summary>
            <param name="scanner">scanner</param>
            <returns>the match</returns>
        </member>
        <member name="T:Spart.Parsers.Primitives.StringParser">
            <summary>
            Matches a given string
            </summary>
        </member>
        <member name="M:Spart.Parsers.Primitives.StringParser.#ctor(System.String)">
            <summary>
            constructor
            </summary>
            <param name="str">The string to match</param>
        </member>
        <member name="M:Spart.Parsers.Primitives.StringParser.ParseMain(Spart.Scanners.IScanner)">
            <summary>
            Inner parse method
            </summary>
            <param name="scanner">scanner</param>
            <returns>the match</returns>
        </member>
        <member name="P:Spart.Parsers.Primitives.StringParser.MatchedString">
            <summary>
            the string to match
            </summary>
        </member>
        <member name="T:Spart.Parsers.Prims">
            <summary>
            Static helper class to create primitive parsers
            </summary>
        </member>
        <member name="M:Spart.Parsers.Prims.Ch(System.Char)">
            <summary>
            Creates a parser that matches a single character
            </summary>
            <param name="matchCharacter">character to match</param>
            <returns></returns>
        </member>
        <member name="M:Spart.Parsers.Prims.Str(System.String)">
            <summary>
            Creates a parser that matches a string
            </summary>
            <param name="s">string to match</param>
            <returns></returns>
        </member>
        <member name="M:Spart.Parsers.Prims.Range(System.Char,System.Char)">
            <summary>
            Creates a parser that matches a range of character
            </summary>
            <param name="first"></param>
            <param name="last"></param>
            <returns></returns>
        </member>
        <member name="M:Spart.Parsers.Prims.AnyCharTester(System.Char)">
            <summary>
            Recognizes all characters
            </summary>
            <param name="c">the character to try to recognize</param>
            <returns>always true</returns>
        </member>
        <member name="M:Spart.Parsers.Prims.HexDigitCharTester(System.Char)">
            <summary>
            Recognizes a hexadecimal digit (0..9 a..f A..F)
            </summary>
            <param name="c">the character to try to recognize</param>
            <returns>true if recognized, false if not</returns>
        </member>
        <member name="P:Spart.Parsers.Prims.AnyChar">
            <summary>
            Creates a parser that matches any character
            </summary>
        </member>
        <member name="P:Spart.Parsers.Prims.Control">
            <summary>
            Creates a parser that matches control characters
            </summary>
        </member>
        <member name="P:Spart.Parsers.Prims.Digit">
            <summary>
            Creates a parser that matches digit characters
            </summary>
        </member>
        <member name="P:Spart.Parsers.Prims.HexDigit">
            <summary>
            Creates a parser that matches hexadecimal digit characters
            </summary>
        </member>
        <member name="P:Spart.Parsers.Prims.Letter">
            <summary>
            Creates a parser that matches letter characters
            </summary>
        </member>
        <member name="P:Spart.Parsers.Prims.LetterOrDigit">
            <summary>
            Creates a parser that matches letter or digit characters
            </summary>
        </member>
        <member name="P:Spart.Parsers.Prims.Lower">
            <summary>
            Creates a parser that matches lower case characters
            </summary>
        </member>
        <member name="P:Spart.Parsers.Prims.Punctuation">
            <summary>
            Creates a parser that matches punctuation characters
            </summary>
        </member>
        <member name="P:Spart.Parsers.Prims.Separator">
            <summary>
            Creates a parser that matches separator characters
            </summary>
        </member>
        <member name="P:Spart.Parsers.Prims.Symbol">
            <summary>
            Creates a parser that matches symbol characters
            </summary>
        </member>
        <member name="P:Spart.Parsers.Prims.Upper">
            <summary>
            Creates a parser that matches upper case characters
            </summary>
        </member>
        <member name="P:Spart.Parsers.Prims.WhiteSpace">
            <summary>
            Creates a parser that matches whitespace characters
            </summary>
        </member>
        <member name="P:Spart.Parsers.Prims.Eol">
            <summary>
            Creates a parser that matches and end of line
            </summary>
        </member>
        <member name="P:Spart.Parsers.Prims.End">
            <summary>
            Creates a parser that matches the end of the input
            </summary>
        </member>
        <member name="T:Spart.Scanners.IFilter">
            <summary>
            Input filter interface
            </summary>
        </member>
        <member name="M:Spart.Scanners.IFilter.Filter(System.String)">
            <summary>
            Converts string to anther string
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:Spart.Scanners.IFilter.Filter(System.Char)">
            <summary>
            Converts c to another char
            </summary>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="T:Spart.Scanners.IScanner">
            <summary>
            Input scanner interface
            </summary>
        </member>
        <member name="M:Spart.Scanners.IScanner.Read">
            <summary>
            Reads one character of the input
            </summary>
            <returns>true if not at end</returns>
        </member>
        <member name="M:Spart.Scanners.IScanner.Peek">
            <summary>
            Current character
            </summary>
            <returns></returns>
        </member>
        <member name="M:Spart.Scanners.IScanner.Seek(System.Int64)">
            <summary>
            Move cursor position to the offset
            </summary>
            <param name="offset"></param>
        </member>
        <member name="M:Spart.Scanners.IScanner.Substring(System.Int64,System.Int32)">
            <summary>
            Extracts a substring of the input
            </summary>
            <param name="offset"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="P:Spart.Scanners.IScanner.AtEnd">
            <summary>
            Return true if all input is consummed
            </summary>
        </member>
        <member name="P:Spart.Scanners.IScanner.Offset">
            <summary>
            Scanner cursor position
            </summary>
        </member>
        <member name="P:Spart.Scanners.IScanner.Filter">
            <summary>
            Sets the input filter
            </summary>
        </member>
        <member name="T:Spart.Scanners.StringScanner">
            <summary>
            Scanner acting on a string.
            <seealso cref="T:Spart.Scanners.IScanner"/>
            </summary>
        </member>
        <member name="M:Spart.Scanners.StringScanner.#ctor(System.String)">
            <summary>
            Creates a scanner on the string.
            </summary>
            <param name="inputString">Input string</param>
            <exception cref="T:System.ArgumentNullException">input string is null</exception>
        </member>
        <member name="M:Spart.Scanners.StringScanner.#ctor(System.String,System.Int64)">
            <summary>
            Creates a scanner on the string at a specified offset
            </summary>
            <param name="inputString">Input string</param>
            <param name="offset">start position for scanner</param>
            <exception cref="T:System.ArgumentNullException">input string is null</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">offset if out of range</exception>
        </member>
        <member name="M:Spart.Scanners.StringScanner.Read">
            <summary>
            Advance the cursor once
            </summary>
            <returns>true if not at end</returns>
            <exception cref="T:System.InvalidOperationException">If called while AtEnd is true</exception>
        </member>
        <member name="M:Spart.Scanners.StringScanner.Peek">
            <summary>
            Current character
            </summary>
            <returns>character at cursor position</returns>
        </member>
        <member name="M:Spart.Scanners.StringScanner.Substring(System.Int64,System.Int32)">
            <summary>
            Extracts a substring 
            </summary>
            <param name="offset"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:Spart.Scanners.StringScanner.Seek(System.Int64)">
            <summary>
            Moves the cursor to the offset position
            </summary>
            <param name="offset"></param>
        </member>
        <member name="P:Spart.Scanners.StringScanner.InputString">
            <summary>
            the input string
            </summary>
        </member>
        <member name="P:Spart.Scanners.StringScanner.Offset">
            <summary>
            Current offset
            </summary>
        </member>
        <member name="P:Spart.Scanners.StringScanner.AtEnd">
            <summary>
            true if at the end of the string
            </summary>
        </member>
        <member name="P:Spart.Scanners.StringScanner.Filter">
            <summary>
            Current filter
            </summary>
        </member>
        <member name="T:Spart.Scanners.ToLowerFilter">
            <summary>
            A to lower input filter
            </summary>
        </member>
        <member name="M:Spart.Scanners.ToLowerFilter.Filter(System.String)">
            <summary>
            Converts s to lower string
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:Spart.Scanners.ToLowerFilter.Filter(System.Char)">
            <summary>
            Converts i to lower i
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="T:Palaso.Annotations.Annotation">
            <summary>
            An annotation is a like a "flag" on a field. You can say, e.g., "I'm not sure about this"
            </summary>
        </member>
        <member name="F:Palaso.Annotations.Annotation._status">
            <summary>
            0 means "off".  1 means "starred". In the future, other positive values could correspond to other icon.
            </summary>
        </member>
        <member name="F:Palaso.Text.ApproximateMatcherOptions.None">
            <summary>
            Find closest forms only
            </summary>
        </member>
        <member name="T:Palaso.Text.LanguageForm">
            <summary>
            A LanguageForm is a unicode string plus the id of its writing system
            </summary>
        </member>
        <member name="F:Palaso.Text.LanguageForm._parent">
            <summary>
            See the comment on MultiText._parent for information on 
            this field.
            </summary>
        </member>
        <member name="M:Palaso.Text.LanguageForm.#ctor">
            <summary>
            for netreflector
            </summary>
        </member>
        <member name="P:Palaso.Text.LanguageForm.Parent">
            <summary>
            See the comment on MultiText._parent for information on 
            this field.
            </summary>
        </member>
        <member name="M:Palaso.Text.MultiTextBase.ContainsAlternative(System.String)">
            <summary>
            Throws exception if alternative does not exist.
            </summary>
            <param name="writingSystemId"></param>
            <returns></returns>
        </member>
        <member name="M:Palaso.Text.MultiTextBase.GetExactAlternative(System.String)">
            <summary>
            Get exact alternative or String.Empty
            </summary>
            <param name="writingSystemId"></param>
            <returns></returns>
        </member>
        <member name="M:Palaso.Text.MultiTextBase.GetBestAlternative(System.String)">
            <summary>
            Gives the string of the requested id if it exists, else the 'first'(?) one that does exist, else Empty String
            </summary>
            <returns></returns>
        </member>
        <member name="M:Palaso.Text.MultiTextBase.GetAlternative(System.String,System.Boolean,System.String)">
            <summary>
            Get a string out
            </summary>
            <returns>the string of the requested id if it exists, 
            else the 'first'(?) one that does exist + the suffix, 
            else the given suffix </returns>
        </member>
        <member name="M:Palaso.Text.MultiTextBase.GetBestAlternative(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Try to get an alternative according to the ws's given(e.g. the enabled writing systems for a field)
            </summary>
            <param name="orderedListOfWritingSystemIds"></param>
            <returns>May return null!</returns>
        </member>
        <member name="M:Palaso.Text.MultiTextBase.TryMergeIn(Palaso.Text.MultiTextBase)">
            <summary>
            Will merge the two mt's if they are compatible; if they collide anywhere, leaves the original untouched 
            and returns false
            </summary>
            <param name="incoming"></param>
            <returns></returns>
        </member>
        <member name="M:Palaso.Text.MultiTextBase.CanBeUnifiedWith(Palaso.Text.MultiTextBase)">
            <summary>
            False if they have different forms on any single writing system. If true, they can be safely merged.
            </summary>
            <param name="incoming"></param>
            <returns></returns>
        </member>
        <member name="E:Palaso.Text.MultiTextBase.PropertyChanged">
            <summary>
            For INotifyPropertyChanged
            </summary>
        </member>
        <member name="P:Palaso.Text.MultiTextBase.Forms">
            <summary>
            just for deserialization
            </summary>
        </member>
        <member name="P:Palaso.UiBindings.IBindableControl`1.Value">
            <summary>
            The value or a key, as appropriate
            </summary>
        </member>
        <member name="P:Palaso.UiBindings.IValueHolder`1.Value">
            <summary>
            The value or a key, as appropriate
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Palaso.UiBindings.StringToObjectEnumerableWrapper" -->
        <member name="M:Palaso.WritingSystems.Collation.IcuRulesCollator.Compare(System.String,System.String)">
            <summary>Compares two strings and returns a value indicating whether one is less than, 
             equal to, or greater than the other.</summary>
            
            <returns>Less than zero when string1 is less than string2.
              Zero when string1 equals string2.
              Greater than zero when string1 is greater than string2.
            </returns>
            
            <param name="string1">The first string to compare.</param>
            <param name="string2">The second object to compare.</param>
        </member>
        <member name="M:Palaso.WritingSystems.Collation.AddSortKeysToXml.AddSortKeys(System.Xml.XPath.XPathNavigator,System.String,Palaso.WritingSystems.Collation.AddSortKeysToXml.SortKeyGenerator,System.String,System.String)">
            <summary>
            Annotate an xml document with a sort key suitable for xslt version 1 sorting algorithms (use lang='en')
            </summary>
            <param name="document">input to add sort keys to</param>
            <param name="xpathSortKeySource">an xpath that selects the source to use to create a sort key</param>
            <param name="sortKeyGenerator">delegate that returns a SortKey given a string</param>
            <param name="xpathElementToPutSortKeyAttributeIn">a relative xpath (from the source) that selects the element to put the sortkey attribute in</param>
            <param name="attribute">The sort key attribute</param>
        </member>
        <member name="M:Palaso.WritingSystems.Collation.AddSortKeysToXml.AddSortKeys(System.Xml.XPath.XPathNavigator,System.String,Palaso.WritingSystems.Collation.AddSortKeysToXml.SortKeyGenerator,System.String,System.String,System.String,System.String)">
            <summary>
            Annotate an xml document with a sort key suitable for xslt version 1 sorting algorithms (use lang='en')
            </summary>
            <param name="document">input to add sort keys to</param>
            <param name="xpathSortKeySource">an xpath that selects the source to use to create a sort key</param>
            <param name="sortKeyGenerator">delegate that returns a SortKey given a string</param>
            <param name="xpathElementToPutSortKeyAttributeIn">a relative xpath (from the source) that selects the element to put the sortkey attribute in</param>
            <param name="prefix">The prefix of the sort-key attribute</param>
            <param name="attribute">The sort key attribute</param>
            <param name="namespaceUri">The namespace of the sortkey attribute</param>
        </member>
        <member name="T:Palaso.WritingSystems.WritingSystemCompatibility">
            <summary>
             Specifies any comaptibiltiy modes that can be imposed on a WritingSystemRepository
            </summary>
        </member>
        <member name="F:Palaso.WritingSystems.WritingSystemCompatibility.Strict">
            <summary>
             Strict adherence to the current LDML standard (with extensions)
            </summary>
        </member>
        <member name="F:Palaso.WritingSystems.WritingSystemCompatibility.Flex7V0Compatible">
            <summary>
             Permits backward compatibility with Flex 7.0.x and 7.1.x V0 LDML
             notably custom language tags having all elements in private use.
             e.g. x-abc-Zxxx-x-audio
            </summary>
        </member>
        <member name="M:Palaso.WritingSystems.IWritingSystemRepository.Set(Palaso.WritingSystems.WritingSystemDefinition)">
            <summary>
            Adds the writing system to the store or updates the store information about
            an already-existing writing system.  Set should be called when there is a change
            that updates the RFC5646 information.
            </summary>
        </member>
        <member name="M:Palaso.WritingSystems.IWritingSystemRepository.CanSet(Palaso.WritingSystems.WritingSystemDefinition)">
            <summary>
            Returns true if a call to Set should succeed, false if a call to Set would throw
            </summary>
        </member>
        <member name="M:Palaso.WritingSystems.IWritingSystemRepository.Get(System.String)">
            <summary>
            Gets the writing system object for the given Store ID
            </summary>
        </member>
        <member name="M:Palaso.WritingSystems.IWritingSystemRepository.GetNewStoreIDWhenSet(Palaso.WritingSystems.WritingSystemDefinition)">
            <summary>
            If the given writing system were passed to Set, this function returns the
            new StoreID that would be assigned.
            </summary>
        </member>
        <member name="M:Palaso.WritingSystems.IWritingSystemRepository.Exists(System.String)">
            <summary>
            Returns true if a writing system with the given Store ID exists in the store
            Contains is preferred
            </summary>
        </member>
        <member name="M:Palaso.WritingSystems.IWritingSystemRepository.Contains(System.String)">
            <summary>
            Returns true if a writing system with the given Store ID exists in the store
            </summary>
        </member>
        <member name="M:Palaso.WritingSystems.IWritingSystemRepository.CreateNew">
            <summary>
            Creates a new writing system object and returns it.  Set will need to be called
            once identifying information has been changed in order to save it in the store.
            </summary>
        </member>
        <member name="M:Palaso.WritingSystems.IWritingSystemRepository.Remove(System.String)">
            <summary>
            Removes the writing system with the specified Store ID from the store.
            </summary>
        </member>
        <member name="M:Palaso.WritingSystems.IWritingSystemRepository.MakeDuplicate(Palaso.WritingSystems.WritingSystemDefinition)">
            <summary>
            Makes a duplicate of an existing writing system definition.  Set will need
            to be called with this new duplicate once identifying information has been changed
            in order to place the new definition in the store.
            </summary>
        </member>
        <member name="M:Palaso.WritingSystems.IWritingSystemRepository.WritingSystemIdHasChanged(System.String)">
            <summary>
            If a consumer has a writingSystemId that is not contained in the
            repository he can query the repository as to whether the id was once
            contained and has since changed.
            Note that changes are only logged on Save() i.e. changes made between
            saves are not tracked
            Use WritingSystemIdHasChangedTo to determine the new Id if there has 
            been a change
            </summary>
        </member>
        <member name="M:Palaso.WritingSystems.IWritingSystemRepository.WritingSystemIdHasChangedTo(System.String)">
            <summary>
            If a consumer has a writing system ID that was once contained in this
            repository, but has since been changed, this method will return the
            new ID. If there are multiple possibilities or if the ID was never
            contained in the repo the method will return null. If the consumer 
            queries for an ID that has not changed and is still contained in the
            repo it will return the ID.
            Note that changes are only logged on Save() i.e. changes made between
            saves are not tracked
            Use WritingSystemIdHasChanged to determine whether an Id has changed 
            at all
            </summary>
        </member>
        <member name="M:Palaso.WritingSystems.IWritingSystemRepository.Save">
            <summary>
            Writes the store to a persistable medium, if applicable.
            </summary>
        </member>
        <member name="M:Palaso.WritingSystems.IWritingSystemRepository.WritingSystemsNewerIn(System.Collections.Generic.IEnumerable{Palaso.WritingSystems.WritingSystemDefinition})">
            <summary>
            Returns a list of writing systems from rhs which are newer than ones in the store.
            </summary>
        </member>
        <member name="M:Palaso.WritingSystems.IWritingSystemRepository.OnWritingSystemIDChange(Palaso.WritingSystems.WritingSystemDefinition,System.String)">
            <summary>
            Event Handler that updates the store when a writing system id has changed
            </summary>
        </member>
        <member name="M:Palaso.WritingSystems.IWritingSystemRepository.FilterForTextIds(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
             Returns a list of writing system tags that apply only to text based writing systems.
             i.e. audio writing systems (and all non written writing systems) are excluded.
            </summary>
            <param name="idsToFilter"></param>
            <returns></returns>
        </member>
        <member name="E:Palaso.WritingSystems.IWritingSystemRepository.WritingSystemIdChanged">
            <summary>
            Notifies a consuming class of a changed writing system id on Set()
            </summary>
        </member>
        <member name="E:Palaso.WritingSystems.IWritingSystemRepository.WritingSystemDeleted">
            <summary>
            Notifies a consuming class of a changed writing system id on Set()
            </summary>
        </member>
        <member name="P:Palaso.WritingSystems.IWritingSystemRepository.Count">
            <summary>
            Gives the total number of writing systems in the store
            </summary>
        </member>
        <member name="P:Palaso.WritingSystems.IWritingSystemRepository.WritingSystemDefinitions">
            <summary>
            Returns a list of all writing system definitions in the store.
            </summary>
        </member>
        <member name="P:Palaso.WritingSystems.IWritingSystemRepository.AllWritingSystems">
            <summary>
            Returns a list of all writing system definitions in the store.
            </summary>
        </member>
        <member name="P:Palaso.WritingSystems.IWritingSystemRepository.TextWritingSystems">
            <summary>
            Returns a list of *text* writing systems in the store
            </summary>
        </member>
        <member name="P:Palaso.WritingSystems.IWritingSystemRepository.VoiceWritingSystems">
            <summary>
            Returns a list of *audio* writing systems in the store
            </summary>
        </member>
        <member name="P:Palaso.WritingSystems.IWritingSystemRepository.CompatibilityMode">
            <summary>
             Gets / Sets the compatibilitiy mode imposed on this repository.
            </summary>
        </member>
        <member name="T:Palaso.WritingSystems.LdmlDataMapper">
            <summary>
            The LdmlDatamapper Reads and Writes WritingSystemDefinitions to LDML files. A typical consuming application should not
            need to use the LdmlDataMapper directly but should rather use an IWritingSystemRepository (such as the 
            LdmlInfolderWritingSystemRepository) to manage it's writing systems.
            The LdmlDatamapper is tightly tied to a particular (palaso) version of LDML. If the LdmlDatamapper refuses to Read a
            particular Ldml file it may need to be migrated to the latest version. Please use the 
            LdmlInFolderWritingSystemRepository class for this purpose.
            Please note that the LdmlDataMapper.Write method can round trip data that it does not understand if passed an
            appropriate stream or xmlreader produced from the old file.
            Be aware that as of Jul-5-2011 an exception was made for certain well defined Fieldworks LDML files whose contained 
            Rfc5646 tag begin with "x-". These will load correctly, albeit in a transformed state, in spite of being "Version 0".
            Furthermore writing systems containing RfcTags beginning with "x-" and that have a matching Fieldworks conform LDML file
            in the repository will not be changed including no marking with "version 1".
            </summary>
        </member>
        <member name="M:Palaso.WritingSystems.LdmlDataMapper.Write(System.String,Palaso.WritingSystems.WritingSystemDefinition,System.IO.Stream,Palaso.WritingSystems.WritingSystemCompatibility)">
            <summary>
            The "oldFile" parameter allows the LdmldataMapper to allow data that it doesn't understand to be roundtripped.
            </summary>
            <param name="filePath"></param>
            <param name="ws"></param>
            <param name="oldFile"></param>
            <param name="compatibilityMode"></param>
        </member>
        <member name="M:Palaso.WritingSystems.LdmlDataMapper.Write(System.Xml.XmlWriter,Palaso.WritingSystems.WritingSystemDefinition,System.Xml.XmlReader,Palaso.WritingSystems.WritingSystemCompatibility)">
            <summary>
            The "oldFileReader" parameter allows the LdmldataMapper to allow data that it doesn't understand to be roundtripped.
            </summary>
            <param name="filePath"></param>
            <param name="ws"></param>
            <param name="oldFile"></param>
        </member>
        <member name="M:Palaso.WritingSystems.Collation.SimpleRulesCollator.Compare(System.String,System.String)">
            <summary>Compares two strings and returns a value indicating whether one is less than, 
             equal to, or greater than the other.</summary>
            
            <returns>Less than zero when string1 is less than string2.
              Zero when string1 equals string2.
              Greater than zero when string1 is greater than string2.
            </returns>
            
            <param name="string1">The first string to compare.</param>
            <param name="string2">The second object to compare.</param>
        </member>
        <member name="M:Palaso.WritingSystems.Collation.SimpleRulesCollator.SimpleCollationRuleParser.IsCharacter(System.Char)">
            <summary>
            Check whether the given character should be recognized
            </summary>
            <param name="c">the character to try to recognize</param>
            <returns>true if recognized, false if not</returns>
        </member>
        <member name="M:Palaso.WritingSystems.Collation.SimpleRulesCollator.SimpleCollationRuleParser.#ctor">
            <summary>
            A very simple calculator parser
            </summary>
        </member>
        <member name="M:Palaso.WritingSystems.Collation.SimpleRulesCollator.SimpleCollationRuleParser.ConvertToIcuTailoringRule(System.String)">
            <summary>
            Parse a string and return parse match
            </summary>
            <param name="rules"></param>
            <returns></returns>
        </member>
        <member name="T:Palaso.WritingSystems.WritingSystemRepositoryBase">
            <summary>
            This class forms the bases for managing collections of WritingSystemDefinitions. WritingSystemDefinitions
            can be registered and then retrieved and deleted by Id. The preferred use when editting a WritingSystemDefinition stored 
            in the WritingSystemRepository is to Get the WritingSystemDefinition in question and then to clone it either via the
            Clone method on WritingSystemDefinition or via the MakeDuplicate method on the WritingSystemRepository. This allows
            changes made to a WritingSystemDefinition to be registered back with the WritingSystemRepository via the Set method,
            or to be discarded by simply discarding the object.
            Internally the WritingSystemRepository uses the WritingSystemDefinition's StoreId property to establish the identity of
            a WritingSystemDefinition. This allows the user to change the Rfc646Tag components and thereby the Id of a 
            WritingSystemDefinition and the WritingSystemRepository to update itself and the underlying store correctly.
            </summary>
        </member>
        <member name="M:Palaso.WritingSystems.WritingSystemRepositoryBase.#ctor(Palaso.WritingSystems.WritingSystemCompatibility)">
            <summary>
            Constructor, set the CompatibilityMode
            </summary>
        </member>
        <member name="M:Palaso.WritingSystems.LdmlInFolderWritingSystemRepository.Initialize(System.String,Palaso.WritingSystems.Migration.WritingSystemsLdmlV0To1Migration.LdmlVersion0MigrationStrategy.MigrationHandler,Palaso.WritingSystems.WritingSystemLoadProblemHandler)">
            <summary>
             Returns an instance of an ldml in folder writing system reposistory.
            </summary>
            <param name="basePath">base location of the global writing system repository</param>
            <param name="migrationHandler">Callback if during the initialization any writing system id's are changed</param>
            <param name="loadProblemHandler">Callback if during the initialization any writing systems cannot be loaded</param>
        </member>
        <member name="M:Palaso.WritingSystems.LdmlInFolderWritingSystemRepository.Initialize(System.String,Palaso.WritingSystems.Migration.WritingSystemsLdmlV0To1Migration.LdmlVersion0MigrationStrategy.MigrationHandler,Palaso.WritingSystems.WritingSystemLoadProblemHandler,Palaso.WritingSystems.WritingSystemCompatibility)">
            <summary>
             Returns an instance of an ldml in folder writing system reposistory.
            </summary>
            <param name="basePath">base location of the global writing system repository</param>
            <param name="migrationHandler">Callback if during the initialization any writing system id's are changed</param>
            <param name="loadProblemHandler">Callback if during the initialization any writing systems cannot be loaded</param>
            <param name="roundtripFlex70PrivateUse"></param>
        </member>
        <member name="M:Palaso.WritingSystems.LdmlInFolderWritingSystemRepository.#ctor(System.String)">
            <summary>
            use a special path for the repository
            </summary>
            <param name="basePath"></param>
        </member>
        <member name="M:Palaso.WritingSystems.LdmlInFolderWritingSystemRepository.#ctor(System.String,Palaso.WritingSystems.WritingSystemCompatibility)">
            <summary>
            use a special path for the repository
            </summary>
            <param name="basePath"></param>
            <param name="compatibilityMode"></param>
        </member>
        <member name="M:Palaso.WritingSystems.LdmlInFolderWritingSystemRepository.GetFilePathFromIdentifier(System.String)">
            <summary>
             Returns the full path to the underlying store for this writing system.
            </summary>
            <param name="identifier"></param>
            <returns>FilePath</returns>
        </member>
        <member name="P:Palaso.WritingSystems.LdmlInFolderWritingSystemRepository.SystemWritingSystemProvider">
            <summary>
            Provides writing systems from a repository that comes, for example, with the OS
            </summary>
        </member>
        <member name="M:Palaso.WritingSystems.LdmlInXmlWritingSystemRepository.#ctor">
            <summary>
            Use the default repository
            </summary>
        </member>
        <member name="T:Palaso.WritingSystems.LdmlNodeComparer">
            <summary>
            Class for comparison of order of nodes in an LDML document.
            Based on http://www.unicode.org/cldr/data/docs/design/ldml_canonical_form.html
            The supplemental metadata shipped with the current CLDR release will have more complete
            element and attribute order data.
            </summary>
        </member>
        <member name="M:Palaso.WritingSystems.LdmlNodeComparer.CompareAttributeValues(System.Xml.XmlNode,System.Xml.XmlNode)">
            <summary>
            Compares two attribute values.  There is a value order table that defines the order of values
            for some attributes of some elements.  After that, sort in numeric order, and then in alphabetic order.
            There is a more complicated rule for the "type" attribute of the "zone" element, but since we're
            not using that element at this time, I'm not going to try to write code for it.
            </summary>
        </member>
        <member name="T:Palaso.WritingSystems.Migration.GlobalWritingSystemRepositoryMigrator">
            <summary>
             This migrates the global writing system repository. This migrator will not remove older versions of the repository, rather
             it leaves the older versions behind for apps that may be running older versions of the palaso library.
             Note that the migrator does not continue to harvest data from older versions of the library.
            </summary>
        </member>
        <member name="M:Palaso.WritingSystems.Migration.GlobalWritingSystemRepositoryMigrator.#ctor(System.String,Palaso.WritingSystems.Migration.WritingSystemsLdmlV0To1Migration.LdmlVersion0MigrationStrategy.MigrationHandler)">
            <summary>
             Initializes the migrator with the given basePath (i.e. excluding the version), and a callback
             for informing the consumer of changes to writing system tags during migration. Applications
             should ensure that all writing systems tags they store are updated accordingly when the callback
             is called.
            </summary>
            <param name="basePath"></param>
            <param name="migrationHandler"></param>
        </member>
        <member name="M:Palaso.WritingSystems.Migration.GlobalWritingSystemRepositoryMigrator.NeedsMigration">
            <summary>
             Returns true if migration is required. Simply returns true if the destination folder is present.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Palaso.WritingSystems.Migration.GlobalWritingSystemRepositoryMigrator.Migrate">
            <summary>
             Performs the migration. If existing, but old, ldml is present then it is migrated. Failing that
             ldml is harvested from older versions of the library, or the older flex location.
             If both old palaso, and flex locations have the same ldml file the flex version is preferred.
            </summary>
        </member>
        <member name="M:Palaso.WritingSystems.Migration.GlobalWritingSystemRepositoryMigrator.VersionPath(System.Int32)">
            <summary>
             Returns the versioned path to the global writing system store (i.e. including the version).
            </summary>
            <param name="version"></param>
            <returns></returns>
        </member>
        <member name="P:Palaso.WritingSystems.Migration.GlobalWritingSystemRepositoryMigrator.FlexLdmlPathPre0">
            <summary>
             The path to old flex ldml files.
            </summary>
        </member>
        <member name="P:Palaso.WritingSystems.Migration.GlobalWritingSystemRepositoryMigrator.PalasoLdmlPathPre0">
            <summary>
             The path to old palaso ldml files.
            </summary>
        </member>
        <member name="P:Palaso.WritingSystems.Migration.GlobalWritingSystemRepositoryMigrator.BasePath">
            <summary>
             The base path (i.e. excluding the version) to the global writing system store.
            </summary>
        </member>
        <member name="P:Palaso.WritingSystems.Migration.GlobalWritingSystemRepositoryMigrator.CurrentVersionPath">
            <summary>
             Returns the versioned path to the current global writing system store.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Palaso.WritingSystems.Migration.Rfc5646TagCleaner.MoveFirstPartToPrivateUseIfNecessary(Palaso.WritingSystems.Migration.Rfc5646TagCleaner.SubTag,Palaso.Func{System.Boolean,System.String},System.String,System.Boolean)">
            <summary>
            This is used to move one part if appropriate from the 'from' subtag to private use.
            Alternatively, if any part is appropriate for the tag according to the test predicate,
            it is moved to the first position (unless it follows an x- and keepStandardPartInPrivateUse is true).
            If we didn't find a valid part, but did move something, insert standardPrivateCode at the START of "from".
            As a side effect, this method may remove non-alphanumeric characters from the from tag.
            (I don't like having such a side effect, but it seems necessary to produce the desired behavior).
            </summary>
        </member>
        <member name="M:Palaso.WritingSystems.Migration.Rfc5646TagCleaner.MoveStandardPartToStart(Palaso.WritingSystems.Migration.Rfc5646TagCleaner.SubTag,Palaso.Func{System.Boolean,System.String},System.Boolean)">
            <summary>
            If there is a standard part (that passes test) in the parts of the subtag, move it to the start and return true.
            If keepStandardPartInPrivateUse is true, only a part before the first 'x' may be moved.
            Return true if an acceptable part was found.
            </summary>
        </member>
        <member name="M:Palaso.WritingSystems.Migration.Rfc5646TagCleaner.MoveTagsMatching(Palaso.WritingSystems.Migration.Rfc5646TagCleaner.SubTag,Palaso.WritingSystems.Migration.Rfc5646TagCleaner.SubTag,System.Predicate{System.String},System.Predicate{System.String})">
            <summary>
            This method should move all subtag parts in the 'from' subtag which match the moveAllMatching predicate into the 'to' subtag.
            Because some parts of a subtag may match in more than one language tag area care must be taken to prevent emptying all parts of
            one subtag into another so the first part that matches the keepFirstMatching predicate will not be moved.
            i.e. if the languageTag is 'from' and the regionTag is 'to' and keepFirstMatching matches language codes and moveAllMatching
            matches region codes, all region looking parts would be placed in 'to' with the possible exception of the first language looking 
            part. 
            </summary>
            <param name="from">SubTag to move parts from</param>
            <param name="to">SubTag to move matching parts to</param>
            <param name="moveAllMatching">predicate matching parts to move</param>
            <param name="keepFirstMatching">predicate matching part to keep</param>
        </member>
        <member name="M:Palaso.WritingSystems.Migration.LdmlInFolderWritingSystemRepositoryMigrator.OnFolderMigrationProblem(System.Collections.Generic.IEnumerable{Palaso.Migration.FolderMigrator.FolderMigratorProblem})">
            <summary>
             Converts FolderMigrationProblem probelms to WritingSystemRepositoryProblem stored in MigrationProblems property.
            </summary>
        </member>
        <member name="T:Palaso.WritingSystems.Migration.WritingSystemsLdmlV0To1Migration.WritingSystemDefinitionV0">
            <summary>
            This class stores the information used to define various writing system properties.
            </summary>
        </member>
        <member name="P:Palaso.WritingSystems.Migration.WritingSystemsLdmlV0To1Migration.WritingSystemDefinitionV0.StoreID">
            <summary>
            Other classes that persist this need to know when our id changed, so they can
            clean up the old copy which is based on the old name.
            </summary>
        </member>
        <member name="F:Palaso.WritingSystems.Migration.WritingSystemsLdmlV0To1Migration.WritingSystemDefinitionV0.SortRulesType.DefaultOrdering">
            <summary>
            Default Unicode ordering rules (actually CustomICU without any rules)
            </summary>
        </member>
        <member name="F:Palaso.WritingSystems.Migration.WritingSystemsLdmlV0To1Migration.WritingSystemDefinitionV0.SortRulesType.CustomSimple">
            <summary>
            Custom Simple (Shoebox/Toolbox) style rules
            </summary>
        </member>
        <member name="F:Palaso.WritingSystems.Migration.WritingSystemsLdmlV0To1Migration.WritingSystemDefinitionV0.SortRulesType.CustomICU">
            <summary>
            Custom ICU rules
            </summary>
        </member>
        <member name="F:Palaso.WritingSystems.Migration.WritingSystemsLdmlV0To1Migration.WritingSystemDefinitionV0.SortRulesType.OtherLanguage">
            <summary>
            Use the sort rules from another language. When this is set, the SortRules are interpreted as a cultureId for the language to sort like.
            </summary>
        </member>
        <member name="T:Palaso.WritingSystems.LdmlNodeComparerV0">
            <summary>
            Class for comparison of order of nodes in an LDML document.
            Based on http://www.unicode.org/cldr/data/docs/design/ldml_canonical_form.html
            The supplemental metadata shipped with the current CLDR release will have more complete
            element and attribute order data.
            </summary>
        </member>
        <member name="M:Palaso.WritingSystems.LdmlNodeComparerV0.CompareAttributeValues(System.Xml.XmlNode,System.Xml.XmlNode)">
            <summary>
            Compares two attribute values.  There is a value order table that defines the order of values
            for some attributes of some elements.  After that, sort in numeric order, and then in alphabetic order.
            There is a more complicated rule for the "type" attribute of the "zone" element, but since we're
            not using that element at this time, I'm not going to try to write code for it.
            </summary>
        </member>
        <member name="T:Palaso.WritingSystems.Migration.WritingSystemsLdmlV0To1Migration.LdmlVersion0MigrationStrategy">
            <summary>
            This class is used to migrate an LdmlFile from LDML palaso version 0 (or 1) to 2. It takes any LDML file and transforms
            a non-conformant rfc5646 tag contained therein into a conformant one. Note that the constructor expects a callback
            to help a consumer perform changes to its own files where necassary.
            Also note that the files are not written until all writing systems have been migrated in order to deal correctly 
            with duplicate Rfc5646 tags that might result from migration.
            </summary>
        </member>
        <member name="T:Palaso.WritingSystems.Migration.WritingSystemLdmlVersionGetter">
            <summary>
            This identifies the version of an LDML file via /ldml/special/palaso:version/@value node
            Note that there is an exception for LDML files containing /ldml/identity/language/@type beginning with "x-". 
            This is in order to accomodate Flex LDML files that store enirely private use language tags differently.
            There should also be checks for private use script and region, but we'll wait and see if this is really a problem.
            The counterpart to this exception is found in the LdmlDataMapper which treats these types of files specially.
            </summary>
        </member>
        <member name="T:Palaso.WritingSystems.WritingSystemDefinition">
            <summary>
            This class stores the information used to define various writing system properties. The Language, Script, Region and Variant
            properties conform to the subtags of the same name defined in BCP47 (Rfc5646) and are enforced by the Rfc5646Tag class. it is worth
            noting that for historical reasons this class does not provide seperate fields for variant and private use components as
            defined in BCP47. Instead the ConcatenateVariantAndPrivateUse and SplitVariantAndPrivateUse methods are provided for consumers
            to generate a single variant subtag that contains both fields seperated by "-x-".
            Furthermore the WritingSystemDefinition.WellknownSubtags class provides certain well defined Subtags that carry special meaning
            apart from the IANA subtag registry. In particular this class defines "qaa" as the default "unlisted language" language subtag.
            It should be used when there is no match for a language in the IANA subtag registry. Private use properties are "emic" and "etic"
            which mark phonemic and phonetic writing systems respectively. These must always be used in conjunction with the "fonipa" variant.
            Likewise "audio" marks a writing system as audio and must always be used in conjunction with script "Zxxx". Convenience methods
            are provided for Ipa and Audio properties as IpaStatus and IsVoice respectively.
            </summary>
        </member>
        <member name="M:Palaso.WritingSystems.WritingSystemDefinition.#ctor">
            <summary>
            Creates a new WritingSystemDefinition with Language subtag set to "qaa"
            </summary>
        </member>
        <member name="M:Palaso.WritingSystems.WritingSystemDefinition.#ctor(System.String)">
            <summary>
            Creates a new WritingSystemDefinition by parsing a valid BCP47 tag
            </summary>
            <param name="bcp47Tag">A valid BCP47 tag</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Palaso.WritingSystems.WritingSystemDefinition.#ctor(System.String,System.String,System.String,System.String,System.String,System.Boolean)" -->
        <member name="M:Palaso.WritingSystems.WritingSystemDefinition.#ctor(Palaso.WritingSystems.WritingSystemDefinition)">
            <summary>
            Copy constructor.
            </summary>
            <param name="ws">The ws.</param>
        </member>
        <member name="M:Palaso.WritingSystems.WritingSystemDefinition.AddToVariant(System.String)">
            <summary>
            Adds a valid BCP47 registered variant subtag to the variant. Any other tag is inserted as private use.
            </summary>
            <param name="registeredVariantOrPrivateUseSubtag">A valid variant tag or another tag which will be inserted into private use.</param>
        </member>
        <member name="M:Palaso.WritingSystems.WritingSystemDefinition.SplitVariantAndPrivateUse(System.String,System.String@,System.String@)">
            <summary>
            A convenience method to help consumers deal with variant and private use subtags both being stored in the Variant property.
            This method will search the Variant part of the BCP47 tag for an "x" extension marker and split the tag into variant and private use sections
            Note the complementary method "ConcatenateVariantAndPrivateUse"
            </summary>
            <param name="variantAndPrivateUse">The string containing variant and private use sections seperated by an "x" private use subtag</param>
            <param name="variant">The resulting variant section</param>
            <param name="privateUse">The resulting private use section</param>
        </member>
        <member name="M:Palaso.WritingSystems.WritingSystemDefinition.ConcatenateVariantAndPrivateUse(System.String,System.String)">
            <summary>
            A convenience method to help consumers deal with registeredVariantSubtags and private use subtags both being stored in the Variant property.
            This method will insert a "x" private use subtag between a set of registered BCP47 variants and a set of private use subtags
            Note the complementary method "ConcatenateVariantAndPrivateUse"
            </summary>
            <param name="registeredVariantSubtags">A set of registered variant subtags</param>
            <param name="privateUseSubtags">A set of private use subtags</param>
            <returns>The resulting combination of registeredVariantSubtags and private use.</returns>
        </member>
        <member name="M:Palaso.WritingSystems.WritingSystemDefinition.SetAllComponents(System.String,System.String,System.String,System.String)">
            <summary>
            Sets all BCP47 language tag components at once. 
            This method is useful for avoiding invalid intermediate states when switching from one valid tag to another.
            </summary>
            <param name="language">A valid BCP47 language subtag.</param>
            <param name="script">A valid BCP47 script subtag.</param>
            <param name="region">A valid BCP47 region subtag.</param>
            <param name="variant">A valid BCP47 variant subtag.</param>
        </member>
        <member name="M:Palaso.WritingSystems.WritingSystemDefinition.CreateCopyWithUniqueId(Palaso.WritingSystems.WritingSystemDefinition,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            This method will make a copy of the given writing system and 
            then make the Id unique compared to list of Ids passed in by
            appending dupl# where # is a digit that increases with the
            number of duplicates found.
            </summary>
            <param name="writingSystemToCopy"></param>
            <param name="otherWritingsystemIds"></param>
            <returns></returns>
        </member>
        <member name="M:Palaso.WritingSystems.WritingSystemDefinition.SortUsingOtherLanguage(System.String)">
            <summary>
            A convenience method for sorting like anthoer language
            </summary>
            <param name="languageCode">A valid language code</param>
        </member>
        <member name="M:Palaso.WritingSystems.WritingSystemDefinition.SortUsingCustomICU(System.String)">
            <summary>
            A convenience method for sorting with custom ICU rules
            </summary>
            <param name="sortRules">custom ICU sortrules</param>
        </member>
        <member name="M:Palaso.WritingSystems.WritingSystemDefinition.SortUsingCustomSimple(System.String)">
            <summary>
            A convenience method for sorting with "shoebox" style rules
            </summary>
            <param name="sortRules">"shoebox" style rules</param>
        </member>
        <member name="M:Palaso.WritingSystems.WritingSystemDefinition.ValidateCollationRules(System.String@)">
            <summary>
            Tests whether the current custom collation rules are valid.
            </summary>
            <param name="message">Used for an error message if rules do not validate.</param>
            <returns>True if rules are valid, false otherwise.</returns>
        </member>
        <member name="M:Palaso.WritingSystems.WritingSystemDefinition.Clone">
            <summary>
            Creates a clone of the current writing system. 
            Note that this excludes the properties: Modified, MarkedForDeletion and StoreID
            </summary>
            <returns></returns>
        </member>
        <member name="M:Palaso.WritingSystems.WritingSystemDefinition.SetTagFromString(System.String)">
            <summary>
            Parses the supplied BCP47 tag and sets the Language, Script, Region and Variant properties accordingly
            </summary>
            <param name="completeTag">A valid BCP47 tag</param>
        </member>
        <member name="M:Palaso.WritingSystems.WritingSystemDefinition.Parse(System.String)">
            <summary>
            Parses the supplied BCP47 tag and return a new writing system definition with the correspnding Language, Script, Region and Variant properties
            </summary>
            <param name="bcp47Tag">A valid BCP47 tag</param>
        </member>
        <member name="M:Palaso.WritingSystems.WritingSystemDefinition.FromSubtags(System.String,System.String,System.String,System.String)">
            <summary>
            Returns a new writing system definition with the corresponding Language, Script, Region and Variant properties set
            </summary>
        </member>
        <member name="M:Palaso.WritingSystems.WritingSystemDefinition.FilterWellKnownPrivateUseTags(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Filters out all "WellKnownSubTags" out of a list of subtags
            </summary>
            <param name="privateUseTokens"></param>
            <returns></returns>
        </member>
        <member name="P:Palaso.WritingSystems.WritingSystemDefinition.RequiresValidTag">
            <summary>
            True when the validity of the writing system defn's tag is being enforced. This is the normal and default state.
            Setting this true will throw unless the tag has previously been put into a valid state.
            Attempting to Save the writing system defn will set this true (and may throw).
            </summary>
        </member>
        <member name="P:Palaso.WritingSystems.WritingSystemDefinition.VersionNumber">
            <summary>
            This is the version of the locale data contained in this writing system. 
            This should not be confused with the version of our writingsystemDefinition implementation which is mostly used for migration purposes. 
            That information is stored in the "LatestWritingSystemDefinitionVersion" property.
            </summary>
        </member>
        <member name="P:Palaso.WritingSystems.WritingSystemDefinition.IpaStatus">
            <summary>
            Adjusts the BCP47 tag to indicate the desired form of Ipa by inserting fonipa in the variant and emic or etic in private use where necessary.
            </summary>
        </member>
        <member name="P:Palaso.WritingSystems.WritingSystemDefinition.IsVoice">
            <summary>
            Adjusts the BCP47 tag to indicate that this is an "audio writing system" by inserting "audio" in the private use and "Zxxx" in the script
            </summary>
        </member>
        <member name="P:Palaso.WritingSystems.WritingSystemDefinition.Variant">
            <summary>
            A string representing the subtag of the same name as defined by BCP47. 
            Note that the variant also includes the private use subtags. These are appended to the variant subtags seperated by "-x-"
            Also note the convenience methods "SplitVariantAndPrivateUse" and "ConcatenateVariantAndPrivateUse" for easier 
            variant/ private use handling
            </summary>
        </member>
        <member name="P:Palaso.WritingSystems.WritingSystemDefinition.Region">
            <summary>
            A string representing the subtag of the same name as defined by BCP47. 
            </summary>
        </member>
        <member name="P:Palaso.WritingSystems.WritingSystemDefinition.Language">
            <summary>
            A string representing the subtag of the same name as defined by BCP47. 
            </summary>
        </member>
        <member name="P:Palaso.WritingSystems.WritingSystemDefinition.Abbreviation">
            <summary>
            The desired abbreviation for the writing system
            </summary>
        </member>
        <member name="P:Palaso.WritingSystems.WritingSystemDefinition.Script">
            <summary>
            A string representing the subtag of the same name as defined by BCP47. 
            </summary>
        </member>
        <member name="P:Palaso.WritingSystems.WritingSystemDefinition.LanguageName">
            <summary>
            The language name to use. Typically this is the language name associated with the BCP47 language subtag as defined by the IANA subtag registry
            </summary>
        </member>
        <member name="P:Palaso.WritingSystems.WritingSystemDefinition.StoreID">
            <summary>
            Used by IWritingSystemRepository to identify writing systems. Only change this if you would like to replace a writing system with the same StoreId
            already contained in the repo. This is useful creating a temporary copy of a writing system that you may or may not care to persist to the 
            IWritingSystemRepository.
            Typical use would therefor be:
            ws.Clone(wsorig);
            ws.StoreId=wsOrig.StoreId;
            **make changes to ws**
            repo.Set(ws);
            </summary>
        </member>
        <member name="P:Palaso.WritingSystems.WritingSystemDefinition.DisplayLabel">
            <summary>
            A automatically generated descriptive label for the writing system definition.
            </summary>
        </member>
        <member name="P:Palaso.WritingSystems.WritingSystemDefinition.Bcp47Tag">
            <summary>
            The current BCP47 tag which is a concatenation of the Language, Script, Region and Variant properties.
            </summary>
        </member>
        <member name="P:Palaso.WritingSystems.WritingSystemDefinition.Id">
            <summary>
            The identifier for this writing syetm definition. Use this in files and as a key to the IWritingSystemRepository.
            Note that this is usually identical to the Bcp47 tag and should rarely differ.
            </summary>
        </member>
        <member name="P:Palaso.WritingSystems.WritingSystemDefinition.Modified">
            <summary>
            Indicates whether the writing system definition has been modified.
            Note that this flag is automatically set by all methods that cause a modification and is reset by the IwritingSystemRepository.Save() method
            </summary>
        </member>
        <member name="P:Palaso.WritingSystems.WritingSystemDefinition.DefaultFontName">
            <summary>
            The font used to display data encoded in this writing system
            </summary>
        </member>
        <member name="P:Palaso.WritingSystems.WritingSystemDefinition.DefaultFontSize">
            <summary>
            the preferred font size to use for data encoded in this writing system.
            </summary>
        </member>
        <member name="P:Palaso.WritingSystems.WritingSystemDefinition.Keyboard">
            <summary>
            The preferred keyboard to use to generate data encoded in this writing system.
            </summary>
        </member>
        <member name="P:Palaso.WritingSystems.WritingSystemDefinition.RightToLeftScript">
            <summary>
            Indicates whether this writing system is read and written from left to right or right to left
            </summary>
        </member>
        <member name="P:Palaso.WritingSystems.WritingSystemDefinition.NativeName">
            <summary>
            The windows "NativeName" from the Culture class
            </summary>
        </member>
        <member name="P:Palaso.WritingSystems.WritingSystemDefinition.SortUsing">
            <summary>
            Indicates the type of sort rules used to encode the sort order.
            Note that the actual sort rules are contained in the SortRules property
            </summary>
        </member>
        <member name="P:Palaso.WritingSystems.WritingSystemDefinition.SortRules">
            <summary>
            The sort rules that efine the sort order.
            Note that you must indicate the type of sort rules used by setting the "SortUsing" property
            </summary>
        </member>
        <member name="P:Palaso.WritingSystems.WritingSystemDefinition.SpellCheckingId">
            <summary>
            The id used to select the spell checker.
            </summary>
        </member>
        <member name="P:Palaso.WritingSystems.WritingSystemDefinition.Collator">
            <summary>
            Returns an ICollator interface that can be used to sort strings based
            on the custom collation rules.
            </summary>
        </member>
        <member name="P:Palaso.WritingSystems.WritingSystemDefinition.IsUnicodeEncoded">
            <summary>
            Indicates whether this writing system is unicode encoded or legacy encoded
            </summary>
        </member>
        <member name="F:Palaso.WritingSystems.WritingSystemDefinition.SortRulesType.DefaultOrdering">
            <summary>
            Default Unicode ordering rules (actually CustomICU without any rules)
            </summary>
        </member>
        <member name="F:Palaso.WritingSystems.WritingSystemDefinition.SortRulesType.CustomSimple">
            <summary>
            Custom Simple (Shoebox/Toolbox) style rules
            </summary>
        </member>
        <member name="F:Palaso.WritingSystems.WritingSystemDefinition.SortRulesType.CustomICU">
            <summary>
            Custom ICU rules
            </summary>
        </member>
        <member name="F:Palaso.WritingSystems.WritingSystemDefinition.SortRulesType.OtherLanguage">
            <summary>
            Use the sort rules from another language. When this is set, the SortRules are interpreted as a cultureId for the language to sort like.
            </summary>
        </member>
        <member name="M:Palaso.Xml.XmlHelpersV0.GetOptionalBooleanAttributeValue(System.Xml.XmlNode,System.String,System.Boolean)">
            <summary>
            Get an optional attribute value from an XmlNode.
            </summary>
            <param name="node">The XmlNode to look in.</param>
            <param name="attrName">The attribute to find.</param>
            <param name="defaultValue"></param>
            <returns>The value of the attribute, or the default value, if the attribute dismissing</returns>
        </member>
        <member name="M:Palaso.Xml.XmlHelpersV0.GetBooleanAttributeValue(System.Xml.XmlNode,System.String)">
            <summary>
            Returns true if value of attrName is 'true' or 'yes' (case ignored)
            </summary>
            <param name="node">The XmlNode to look in.</param>
            <param name="attrName">The optional attribute to find.</param>
            <returns></returns>
        </member>
        <member name="M:Palaso.Xml.XmlHelpersV0.GetBooleanAttributeValue(System.String)">
            <summary>
            Returns true if sValue is 'true' or 'yes' (case ignored)
            </summary>
        </member>
        <member name="M:Palaso.Xml.XmlHelpersV0.GetAttributeValue(System.Xml.XmlNode,System.String,System.String)">
            <summary>
            Deprecated: use GetOptionalAttributeValue instead.
            </summary>
            <param name="node"></param>
            <param name="attrName"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Palaso.Xml.XmlHelpersV0.GetAttributeValue(System.Xml.XmlNode,System.String)">
            <summary>
            Get an optional attribute value from an XmlNode.
            </summary>
            <param name="node">The XmlNode to look in.</param>
            <param name="attrName">The attribute to find.</param>
            <returns>The value of the attribute, or null, if not found.</returns>
        </member>
        <member name="M:Palaso.Xml.XmlHelpersV0.GetOptionalAttributeValue(System.Xml.XmlNode,System.String)">
            <summary>
            Get an optional attribute value from an XmlNode.
            </summary>
            <param name="node">The XmlNode to look in.</param>
            <param name="attrName">The attribute to find.</param>
            <returns>The value of the attribute, or null, if not found.</returns>
        </member>
        <member name="M:Palaso.Xml.XmlHelpersV0.GetOptionalAttributeValue(System.Xml.XmlNode,System.String,System.String)">
            <summary>
            Get an optional attribute value from an XmlNode.
            </summary>
            <param name="node">The XmlNode to look in.</param>
            <param name="attrName">The attribute to find.</param>
            <returns>The value of the attribute, or null, if not found.</returns>
        </member>
        <member name="T:Palaso.WritingSystems.WritingSystemOrphanFinder">
            <summary>
            The WritingSystemOrphanFinder class provides a uniform way for dealing with orphaned writing system ids.
            Orphaned writing system ids are writing system ids found in a file that are not contained
            in a given writing system repository.
            The algorithm used:
            1. Find all writing system id contained in the file
            2. For each of these writing system ids check if it is contained in the repo. 
               If so goto step 6.
            3. Check with the repo whether the writing system id has been changed. 
               If so, rename the writing system throughout the file and goto step 6.
            4. Run the tag in question through the RfcTagCleaner and check if the new tag is in the repo.
               If so, rename the writing system throughout the file and goto step 6.
            5. Create a new writing system with "cleaned" id and set it in the repo. 
            6. Complete
            </summary>
        </member>
        <member name="M:Palaso.WritingSystems.WritingSystemOrphanFinder.FindOrphans(System.Collections.Generic.IEnumerable{System.String},Palaso.WritingSystems.WritingSystemOrphanFinder.IdReplacementStrategy,Palaso.WritingSystems.IWritingSystemRepository)">
            <summary>
             Constructor.
            </summary>
            <param name="idsInFile"></param>
            <param name="replaceIdsInFile"></param>
            <param name="writingSystemRepository"></param>
        </member>
        <member name="T:Palaso.WritingSystems.WritingSystemOrphanFinder.IdReplacementStrategy">
            <summary>
             A delegate that implements the actual replacement of writing system tags in the file. 
             The method is given the old writing system id 'oldId' and the new writing system id 'newId'.
            </summary>
            <param name="newId"></param>
            <param name="oldId"></param>
        </member>
        <member name="T:Palaso.WritingSystems.RFC5646Tag">
            <summary>
            The RFC5646Tag class represents a language tag that conforms to Rfc5646. It relies heavily on the StandardTags class for
            valid Language, Script, Region and Variant subtags. The RFC5646 class enforces strict adherence to the Rfc5646 spec.
            Exceptions are:
            - does not support singletons other than "x-"
            - does not support grandfathered, regular or irregular tags
            </summary>
        </member>
        <member name="M:Palaso.WritingSystems.RFC5646Tag.#ctor(Palaso.WritingSystems.RFC5646Tag)">
            <summary>
             Copy constructor
            </summary>
            <param name="rhs"></param>
        </member>
        <member name="M:Palaso.WritingSystems.RFC5646Tag.Parse(System.String)">
            <summary>Constructor method to parse a valid RFC5646 tag as a string
            </summary>
            <param name="inputString">valid RFC5646 string</param>
            <returns>RFC5646Tag object</returns>
        </member>
        <member name="P:Palaso.WritingSystems.RFC5646Tag.RequiresValidTag">
            <summary>
            Setting this true will throw unless the tag has previously been put into a valid state.
            </summary>
        </member>
        <member name="T:Palaso.WritingSystems.StandardTags">
            <summary>
            This class parses the IANA subtag registry in order to provide a list of valid language, script, region and variant subtags
            for use by the Rfc5646Tag and other classes.
            </summary>
        </member>
        <member name="M:Palaso.WritingSystems.StandardTags.IsPrivateUseRegionCode(System.String)">
            <summary>
            Determines whether the specified region code is private use. These are considered valid region codes,
            but not predefined ones with a known meaning.
            </summary>
            <param name="regionCode">The region code.</param>
            <returns>
            	<c>true</c> if the region code is private use.
            </returns>
        </member>
        <member name="P:Palaso.WritingSystems.StandardTags.IanaVariantSubtag.Prefixes">
            <summary>
            A Variant with no prefixes (prefixes will be null) may be applied to any language. One with one or more prefixes may only be
            applied to those language tags which begin with that prefix. (This is currently not enforced, but the information is available
            for use by dialogs which display variant choices.)
            </summary>
        </member>
        <member name="T:Palaso.WritingSystems.GlobalWritingSystemRepository">
            <summary>
             A system wide writing system repoistory
            </summary>
        </member>
        <member name="M:Palaso.WritingSystems.GlobalWritingSystemRepository.Initialize(Palaso.WritingSystems.Migration.WritingSystemsLdmlV0To1Migration.LdmlVersion0MigrationStrategy.MigrationHandler)">
            <summary>
             Initializes the global writing system repository.  Migrates any ldml files if required,
             notifying of any changes of writing system id that occured during migration.
            </summary>
            <param name="migrationHandler"></param>
        </member>
        <member name="M:Palaso.WritingSystems.GlobalWritingSystemRepository.InitializeWithBasePath(System.String,Palaso.WritingSystems.Migration.WritingSystemsLdmlV0To1Migration.LdmlVersion0MigrationStrategy.MigrationHandler)">
            <summary>
             This initializer is intended for tests as it allows setting of the basePath explicitly.
            </summary>
            <param name="basePath">base location of the global writing system repository</param>
            <param name="migrationHandler">Callback if during the initialization any writing system id's are changed</param>
        </member>
        <member name="M:Palaso.WritingSystems.GlobalWritingSystemRepository.#ctor(System.String)">
            <summary>
             Specify the location of the System Writing System repository explicitly.
             This is mostly useful for tests.
            </summary>
            <param name="basePath"></param>
        </member>
        <member name="M:Palaso.WritingSystems.GlobalWritingSystemRepository.CurrentVersionPath(System.String)">
            <summary>
             The CurrentVersionPath is %CommonApplicationData%\SIL\WritingSystemRepository\LatestVersion
             e.g. On Windows 7 this is \ProgramData\SIL\WritingSystemRepository\1
            </summary>
        </member>
        <member name="P:Palaso.WritingSystems.GlobalWritingSystemRepository.Instance">
            <summary>
             Returns an instance of the global writing system reposistory.  Apps must call Intialize prior to calling this.
             Apps are not obliged to use this Singleton Instance of GlobalWritingSystemRepository.  Apps can manage their
             own instance(s) of GlobalWritingSystemRepository returned from Initialize if they so choose.
            </summary>
            <returns>A global IWritingSystemRepository</returns>
        </member>
        <member name="P:Palaso.WritingSystems.GlobalWritingSystemRepository.DefaultBasePath">
            <summary>
             The DefaultBasePath is %CommonApplicationData%\SIL\WritingSystemRepository
             On Windows 7 this is \ProgramData\SIL\WritingSystemRepository\
            </summary>
        </member>
        <member name="P:Palaso.WritingSystems.GlobalWritingSystemRepository.BasePath">
            <summary>
             The BasePath of this instance of GloablWritingSystemRepository.
             e.g. c:\ProgramData\SIL\WritingSystemRepository\
            </summary>
        </member>
        <member name="T:Palaso.WritingSystems.WritingSystemChangeLog">
            <summary>
            This class is used by tthe LdmlInFolderWritingsystemRepository to log any changes that an application makes to the repository.
            The idea is that consumers can query this class to learn of any changes made to contained writing systems by another program 
            and update its other files accordingly.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Palaso.WritingSystems.WritingSystemChangeLogDataMapper.#ctor(System.String)" -->
        <member name="T:Palaso.Xml.CanonicalXmlSettings">
            <summary>
             Canonical xml settings suitable for use in Chorus applications.
            </summary>
        </member>
        <member name="M:Palaso.Xml.CanonicalXmlSettings.CreateXmlWriterSettings(System.Xml.ConformanceLevel)">
            <summary>
             Return an XmlWriterSettings suitable for use in Chorus applications.
            </summary>
             <remarks>
             This formats with new line on attributes, indents with tab, and encoded in UTF8 with no BOM.
             </remarks>
             <param name="conformanceLevel">Document|Fragment</param>
            <returns>XmlWriterSettings</returns>
        </member>
        <member name="M:Palaso.Xml.CanonicalXmlSettings.CreateXmlWriterSettings">
            <summary>
             
            </summary>
            <returns></returns>
        </member>
        <member name="M:Palaso.Xml.XmlHelpers.GetOptionalBooleanAttributeValue(System.Xml.XmlNode,System.String,System.Boolean)">
            <summary>
            Get an optional attribute value from an XmlNode.
            </summary>
            <param name="node">The XmlNode to look in.</param>
            <param name="attrName">The attribute to find.</param>
            <param name="defaultValue"></param>
            <returns>The value of the attribute, or the default value, if the attribute dismissing</returns>
        </member>
        <member name="M:Palaso.Xml.XmlHelpers.GetBooleanAttributeValue(System.Xml.XmlNode,System.String)">
            <summary>
            Returns true if value of attrName is 'true' or 'yes' (case ignored)
            </summary>
            <param name="node">The XmlNode to look in.</param>
            <param name="attrName">The optional attribute to find.</param>
            <returns></returns>
        </member>
        <member name="M:Palaso.Xml.XmlHelpers.GetBooleanAttributeValue(System.String)">
            <summary>
            Returns true if sValue is 'true' or 'yes' (case ignored)
            </summary>
        </member>
        <member name="M:Palaso.Xml.XmlHelpers.GetAttributeValue(System.Xml.XmlNode,System.String,System.String)">
            <summary>
            Deprecated: use GetOptionalAttributeValue instead.
            </summary>
            <param name="node"></param>
            <param name="attrName"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Palaso.Xml.XmlHelpers.GetAttributeValue(System.Xml.XmlNode,System.String)">
            <summary>
            Get an optional attribute value from an XmlNode.
            </summary>
            <param name="node">The XmlNode to look in.</param>
            <param name="attrName">The attribute to find.</param>
            <returns>The value of the attribute, or null, if not found.</returns>
        </member>
        <member name="M:Palaso.Xml.XmlHelpers.GetOptionalAttributeValue(System.Xml.XmlNode,System.String)">
            <summary>
            Get an optional attribute value from an XmlNode.
            </summary>
            <param name="node">The XmlNode to look in.</param>
            <param name="attrName">The attribute to find.</param>
            <returns>The value of the attribute, or null, if not found.</returns>
        </member>
        <member name="M:Palaso.Xml.XmlHelpers.GetOptionalAttributeValue(System.Xml.XmlNode,System.String,System.String)">
            <summary>
            Get an optional attribute value from an XmlNode.
            </summary>
            <param name="node">The XmlNode to look in.</param>
            <param name="attrName">The attribute to find.</param>
            <returns>The value of the attribute, or null, if not found.</returns>
        </member>
        <member name="M:Palaso.Xml.XmlNodeExtensions.SafeSelectNodes(System.Xml.XmlNode,System.String,System.Xml.XmlNamespaceManager)">
            <summary>
            this is safe to use with foreach, unlike SelectNodes
            </summary>
        </member>
        <member name="M:Palaso.Xml.XmlNodeExtensions.SafeSelectNodes(System.Xml.XmlNode,System.String)">
            <summary>
            honors default namespace and will return an empty list rather than null
            </summary>
        </member>
        <member name="T:Palaso.Xml.XmlUtils">
            <summary>
            Summary description for XmlUtils.
            </summary>
        </member>
        <member name="M:Palaso.Xml.XmlUtils.GetBooleanAttributeValue(System.Xml.XmlNode,System.String)">
            <summary>
            Returns true if value of attrName is 'true' or 'yes' (case ignored)
            </summary>
            <param name="node">The XmlNode to look in.</param>
            <param name="attrName">The optional attribute to find.</param>
            <returns></returns>
        </member>
        <member name="M:Palaso.Xml.XmlUtils.GetBooleanAttributeValue(System.Xml.XPath.XPathNavigator,System.String)">
            <summary>
            Returns true if value of attrName is 'true' or 'yes' (case ignored)
            </summary>
            <param name="node">The XmlNode to look in.</param>
            <param name="attrName">The optional attribute to find.</param>
            <returns></returns>
        </member>
        <member name="M:Palaso.Xml.XmlUtils.GetBooleanAttributeValue(System.String)">
            <summary>
            Returns true if sValue is 'true' or 'yes' (case ignored)
            </summary>
        </member>
        <member name="M:Palaso.Xml.XmlUtils.GetMandatoryIntegerAttributeValue(System.Xml.XmlNode,System.String)">
            <summary>
            Returns a integer obtained from the (mandatory) attribute named.
            </summary>
            <param name="node">The XmlNode to look in.</param>
            <param name="attrName">The mandatory attribute to find.</param>
            <returns>The value, or 0 if attr is missing.</returns>
        </member>
        <member name="M:Palaso.Xml.XmlUtils.GetOptionalIntegerValue(System.Xml.XmlNode,System.String,System.Int32)">
            <summary>
            Return an optional integer attribute value, or if not found, the default value.
            </summary>
            <param name="node"></param>
            <param name="attrName"></param>
            <param name="defaultVal"></param>
            <returns></returns>
        </member>
        <member name="M:Palaso.Xml.XmlUtils.GetMandatoryIntegerListAttributeValue(System.Xml.XmlNode,System.String)">
            <summary>
            Retrieve an array, given an attribute consisting of a comma-separated list of integers
            </summary>
            <param name="node"></param>
            <param name="attrName"></param>
            <returns></returns>
        </member>
        <member name="M:Palaso.Xml.XmlUtils.MakeIntegerListValue(System.Int32[])">
            <summary>
            Make a value suitable for GetMandatoryIntegerListAttributeValue to parse.
            </summary>
            <param name="vals"></param>
            <returns></returns>
        </member>
        <member name="M:Palaso.Xml.XmlUtils.MakeListValue(System.Collections.Generic.List{System.Int32})">
            <summary>
            Make a comma-separated list of the ToStrings of the values in the list.
            </summary>
            <param name="vals"></param>
            <returns></returns>
        </member>
        <member name="M:Palaso.Xml.XmlUtils.GetOptionalBooleanAttributeValue(System.Xml.XmlNode,System.String,System.Boolean)">
            <summary>
            Get an optional attribute value from an XmlNode.
            </summary>
            <param name="node">The XmlNode to look in.</param>
            <param name="attrName">The attribute to find.</param>
            <param name="defaultValue"></param>
            <returns>The value of the attribute, or the default value, if the attribute dismissing</returns>
        </member>
        <member name="M:Palaso.Xml.XmlUtils.GetAttributeValue(System.Xml.XmlNode,System.String,System.String)">
            <summary>
            Deprecated: use GetOptionalAttributeValue instead.
            </summary>
            <param name="node"></param>
            <param name="attrName"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Palaso.Xml.XmlUtils.GetAttributeValue(System.Xml.XmlNode,System.String)">
            <summary>
            Get an optional attribute value from an XmlNode.
            </summary>
            <param name="node">The XmlNode to look in.</param>
            <param name="attrName">The attribute to find.</param>
            <returns>The value of the attribute, or null, if not found.</returns>
        </member>
        <member name="M:Palaso.Xml.XmlUtils.GetOptionalAttributeValue(System.Xml.XmlNode,System.String)">
            <summary>
            Get an optional attribute value from an XmlNode.
            </summary>
            <param name="node">The XmlNode to look in.</param>
            <param name="attrName">The attribute to find.</param>
            <returns>The value of the attribute, or null, if not found.</returns>
        </member>
        <member name="M:Palaso.Xml.XmlUtils.GetOptionalAttributeValue(System.Xml.XPath.XPathNavigator,System.String)">
            <summary>
            Get an optional attribute value from an XmlNode.
            </summary>
            <param name="node">The XmlNode to look in.</param>
            <param name="attrName">The attribute to find.</param>
            <returns>The value of the attribute, or null, if not found.</returns>
        </member>
        <member name="M:Palaso.Xml.XmlUtils.GetOptionalAttributeValue(System.Xml.XmlNode,System.String,System.String)">
            <summary>
            Get an optional attribute value from an XmlNode.
            </summary>
            <param name="node">The XmlNode to look in.</param>
            <param name="attrName">The attribute to find.</param>
            <returns>The value of the attribute, or null, if not found.</returns>
            <param name="defaultString"></param>
        </member>
        <member name="M:Palaso.Xml.XmlUtils.GetOptionalAttributeValue(System.Xml.XPath.XPathNavigator,System.String,System.String)">
            <summary>
            Get an optional attribute value from an XmlNode.
            </summary>
            <param name="node">The XmlNode to look in.</param>
            <param name="attrName">The attribute to find.</param>
            <returns>The value of the attribute, or null, if not found.</returns>
            <param name="defaultString"></param>
        </member>
        <member name="M:Palaso.Xml.XmlUtils.FindNode(System.Xml.XmlNode,System.String)">
            <summary>
            Return the node that has the desired 'name', either the input node or a decendent.
            </summary>
            <param name="node">The XmlNode to look in.</param>
            <param name="name">The XmlNode name to find.</param>
            <returns></returns>
        </member>
        <member name="M:Palaso.Xml.XmlUtils.GetManditoryAttributeValue(System.Xml.XmlNode,System.String)">
            <summary>
            Get an obligatory attribute value.
            </summary>
            <param name="node">The XmlNode to look in.</param>
            <param name="attrName">The required attribute to find.</param>
            <returns>The value of the attribute.</returns>
            <exception cref="T:System.ApplicationException">
            Thrown when the value is not found in the node.
            </exception>
        </member>
        <member name="M:Palaso.Xml.XmlUtils.AppendAttribute(System.Xml.XmlNode,System.String,System.String)">
            <summary>
            Append an attribute with the specified name and value to parent.
            </summary>
            <param name="parent"></param>
            <param name="attrName"></param>
            <param name="attrVal"></param>
        </member>
        <member name="M:Palaso.Xml.XmlUtils.NodesMatch(System.Xml.XmlNode,System.Xml.XmlNode)">
            <summary>
            Return true if the two nodes match. Corresponding children should match, and
            corresponding attributes (though not necessarily in the same order).
            The nodes are expected to be actually XmlElements; not tested for other cases.
            Comments do not affect equality.
            </summary>
            <param name="node1"></param>
            <param name="node2"></param>
            <returns></returns>
        </member>
        <member name="M:Palaso.Xml.XmlUtils.GetFirstNonCommentChild(System.Xml.XmlNode)">
            <summary>
            Return the first child of the node that is not a comment (or null).
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="M:Palaso.Xml.XmlUtils.MakeSafeXml(System.String)">
            <summary>
            Fix the string to be safe in a text region of XML.
            </summary>
            <param name="sInput"></param>
            <returns></returns>
        </member>
        <member name="M:Palaso.Xml.XmlUtils.MakeSafeXmlAttribute(System.String)">
            <summary>
            Fix the string to be safe in an attribute value of XML.
            </summary>
            <param name="sInput"></param>
            <returns></returns>
        </member>
        <member name="M:Palaso.Xml.XmlUtils.GetIndendentedXml(System.String)">
            <summary>
            lifted from http://www.knowdotnet.com/articles/indentxml.html
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
    </members>
</doc>

<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Palaso</name>
    </assembly>
    <members>
        <member name="T:Spart.Parsers.Composite.XorParser">
            <summary>
            Recognizes anything which is found in the first parser or the second, but not both
            </summary>
        </member>
        <member name="T:Spart.Parsers.BinaryTerminalParser">
            <summary>
            A Parser with two terminals (which may be parsers themselves)
            </summary>
        </member>
        <member name="T:Spart.Parsers.TerminalParser">
            <summary>
            abstract class Terminal Parser
            </summary>
        </member>
        <member name="T:Spart.Parsers.Parser">
            <summary>
            Abstract parser class
            </summary>
        </member>
        <member name="M:Spart.Parsers.Parser.ParseMain(Spart.Scanners.IScanner)">
            <summary>
            Inner parse method
            </summary>
            <param name="scanner">scanner</param>
            <returns>the match</returns>
        </member>
        <member name="M:Spart.Parsers.Parser.Parse(Spart.Scanners.IScanner)">
            <summary>
            Outer parse method (consumes input)
            </summary>
            <param name="scanner"></param>
            <returns></returns>
        </member>
        <member name="M:Spart.Parsers.Parser.TryAccept(Spart.Scanners.IScanner)">
            <summary>
            Lookahead to determine if parser can be used to parse (does not consume input)
            </summary>
            <param name="scanner"></param>
            <returns></returns>
        </member>
        <member name="M:Spart.Parsers.Parser.OnAction(Spart.Parsers.ParserMatch)">
            <summary>
            Action caller method
            </summary>
            <param name="m"></param>
        </member>
        <member name="M:Spart.Parsers.Parser.op_UnaryPlus(Spart.Parsers.Parser)">
            <summary>
            Unary repeatable operator
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:Spart.Parsers.Parser.op_LogicalNot(Spart.Parsers.Parser)">
            <summary>
            Unary Optional operator
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:Spart.Parsers.Parser.op_BitwiseOr(Spart.Parsers.Parser,Spart.Parsers.Parser)">
            <summary>
            Binary Alternative operator
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Spart.Parsers.Parser.op_BitwiseAnd(Spart.Parsers.Parser,Spart.Parsers.Parser)">
            <summary>
            Binary Intersection operator
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Spart.Parsers.Parser.op_Subtraction(Spart.Parsers.Parser,Spart.Parsers.Parser)">
            <summary>
            Binary Difference operator
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Spart.Parsers.Parser.op_Modulus(Spart.Parsers.Parser,Spart.Parsers.Parser)">
            <summary>
            Binary List operator
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Spart.Parsers.Parser.op_Implicit(System.Char)~Spart.Parsers.Parser">
            <summary>
            Cast operator, creates a Parser that recognizes the given char
            </summary>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:Spart.Parsers.Parser.op_Implicit(System.String)~Spart.Parsers.Parser">
            <summary>
            Cast operator, creates a Parser that recognizes the given string
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="E:Spart.Parsers.Parser.Act">
            <summary>
            Action event
            </summary>
        </member>
        <member name="P:Spart.Parsers.Parser.Item(Spart.Actions.ActionHandler)">
            <summary>
            Applies the given action handler to this parser
            </summary>
            <param name="act">An ActionHandler</param>
            <returns>this</returns>
        </member>
        <member name="M:Spart.Parsers.BinaryTerminalParser.#ctor(Spart.Parsers.Parser,Spart.Parsers.Parser)">
            <summary>
            constructor
            </summary>
            <param name="first"></param>
            <param name="second"></param>
        </member>
        <member name="P:Spart.Parsers.BinaryTerminalParser.FirstParser">
            <summary>
            Access or change the first parser
            </summary>
        </member>
        <member name="P:Spart.Parsers.BinaryTerminalParser.SecondParser">
            <summary>
            Access or change the second parser
            </summary>
        </member>
        <member name="M:Spart.Parsers.Composite.XorParser.#ctor(Spart.Parsers.Parser,Spart.Parsers.Parser)">
            <summary>
            constructor
            </summary>
            <param name="left">match left</param>
            <param name="right">don't match right</param>
        </member>
        <member name="M:Spart.Parsers.Composite.XorParser.ParseMain(Spart.Scanners.IScanner)">
            <summary>
            Inner parse method
            match (first but not second) or (second but not first)
            </summary>
            <param name="scanner">scanner</param>
            <returns>the match</returns>
        </member>
        <member name="T:Spart.Parsers.Composite.DifferenceParser">
            <summary>
            Match first but not second. If both match and the matched text of the second is 
            shorter than the matched text of the first, a successful match is made
            </summary>
        </member>
        <member name="M:Spart.Parsers.Composite.DifferenceParser.#ctor(Spart.Parsers.Parser,Spart.Parsers.Parser)">
            <summary>
            constructor
            </summary>
            <param name="left">match left</param>
            <param name="right">don't match right</param>
        </member>
        <member name="M:Spart.Parsers.Composite.DifferenceParser.ParseMain(Spart.Scanners.IScanner)">
            <summary>
            Inner parse method
            </summary>
            <param name="scanner">scanner</param>
            <returns>the match</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Palaso.Progress.XslTransformWithProgress" -->
        <member name="T:Palaso.Progress.XslTransformWithProgress.CancelingException">
            <summary>
            used to break us out of the xslt transformer if the user cancels
            </summary>
        </member>
        <member name="T:Palaso.Events.EventArgs`1">
            <summary>
            Generic version of EveryArgs, allow to avoid 
            defining custom  EventArgs types 
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Palaso.Events.EventArgs`1.#ctor(`0)">
            <summary>
            Initializes a new instance of the <see cref="T:Palaso.Events.EventArgs`1"/> class.
            </summary>
            <param name="item">The item.</param>
        </member>
        <member name="P:Palaso.Events.EventArgs`1.Item">
            <summary>
            Gets or sets the item for this event args
            </summary>
            <value>The item.</value>
        </member>
        <member name="T:Palaso.Base32.Base32Convert">
            <summary>
             base32 encoding and decoding as defined by RFC4648
             http://rfc.net/rfc4648.html
            </summary>
        </member>
        <member name="M:Palaso.Base32.Base32Convert.ToBase32HexString(System.Collections.Generic.IEnumerable{System.Byte},Palaso.Base32.Base32FormattingOptions)">
            <summary>
            base32hex encoding as defined by RFC4648
            http://rfc.net/rfc4648.html
            One property with this alphabet, which the base64 and base32
            alphabets lack, is that encoded data maintains its sort order when
            the encoded data is compared bit-wise.    
            </summary>
            <remarks>
            This is suitable for encoding sort keys in xml documents such
            that xslt 1 can produce a proper ordering.
            </remarks>
        </member>
        <member name="M:Palaso.Base32.Base32Convert.FromBase32HexString(System.String,Palaso.Base32.Base32FormattingOptions)">
            <summary>
            base32hex decoding as defined by RFC4648
            http://rfc.net/rfc4648.html
            One property with this alphabet, which the base64 and base32
            alphabets lack, is that encoded data maintains its sort order when
            the encoded data is compared bit-wise.    
            </summary>
            <remarks>
            This is suitable for encoding sort keys in xml documents such
            that xslt 1 can produce a proper ordering.
            </remarks>
        </member>
        <member name="T:Palaso.Annotations.Annotation">
            <summary>
            An annotation is a like a "flag" on a field. You can say, e.g., "I'm not sure about this"
            </summary>
        </member>
        <member name="F:Palaso.Annotations.Annotation._status">
            <summary>
            0 means "off".  1 means "starred". In the future, other positive values could correspond to other icon.
            </summary>
        </member>
        <member name="M:Palaso.Reporting.ILogger.WriteConciseHistoricalEvent(System.String,System.Object[])">
            <summary>
            This is something that should be listed in the source control checkin
            </summary>
        </member>
        <member name="M:Palaso.Reporting.MultiLogger.Add(Palaso.Reporting.ILogger)">
            <summary>
            NB: you must handle disposal of the logger yourself (easy with a DI container)
            </summary>
            <param name="logger"></param>
        </member>
        <member name="T:Palaso.Reporting.Logger">
            ----------------------------------------------------------------------------------------
            <summary>
            Logs stuff to a file created in 
            c:\Documents and Settings\Username\Local Settings\Temp\Companyname\Productname\Log.txt
            </summary>
            ----------------------------------------------------------------------------------------
        </member>
        <member name="M:Palaso.Reporting.Logger.Init">
            ------------------------------------------------------------------------------------
            <summary>
            Creates the logger. The logging functions can't be used until this method is 
            called.
            </summary>
            ------------------------------------------------------------------------------------
        </member>
        <member name="M:Palaso.Reporting.Logger.ShutDown">
            ------------------------------------------------------------------------------------
            <summary>
            Shut down the logger. The logging functions can't be used after this method is 
            called.
            </summary>
            ------------------------------------------------------------------------------------
        </member>
        <member name="M:Palaso.Reporting.Logger.CheckDisposed">
            <summary>
            Check to see if the object has been disposed.
            All public Properties and Methods should call this
            before doing anything else.
            </summary>
        </member>
        <member name="F:Palaso.Reporting.Logger.m_isDisposed">
            <summary>
            True, if the object has been disposed.
            </summary>
        </member>
        <member name="M:Palaso.Reporting.Logger.Finalize">
            <summary>
            Finalizer, in case client doesn't dispose it.
            Force Dispose(false) if not already called (i.e. m_isDisposed is true)
            </summary>
            <remarks>
            In case some clients forget to dispose it directly.
            </remarks>
        </member>
        <member name="M:Palaso.Reporting.Logger.WriteConciseHistoricalEvent(System.String,System.Object[])">
            <summary>
            This is for version-control checkin descriptions. E.g. "Deleted foobar".
            </summary>
            <param name="message"></param>
            <param name="args"></param>
        </member>
        <member name="M:Palaso.Reporting.Logger.Dispose">
            <summary>
            
            </summary>
            <remarks>Must not be virtual.</remarks>
        </member>
        <member name="M:Palaso.Reporting.Logger.Dispose(System.Boolean)">
            <summary>
            Executes in two distinct scenarios.
            
            1. If disposing is true, the method has been called directly
            or indirectly by a user's code via the Dispose method.
            Both managed and unmanaged resources can be disposed.
            
            2. If disposing is false, the method has been called by the 
            runtime from inside the finalizer and you should not reference (access) 
            other managed objects, as they already have been garbage collected.
            Only unmanaged resources can be disposed.
            </summary>
            <param name="disposing"></param>
            <remarks>
            If any exceptions are thrown, that is fine.
            If the method is being done in a finalizer, it will be ignored.
            If it is thrown by client code calling Dispose,
            it needs to be handled by fixing the bug.
            
            If subclasses override this method, they should call the base implementation.
            </remarks>
        </member>
        <member name="M:Palaso.Reporting.Logger.WriteEvent(System.String,System.Object[])">
            ------------------------------------------------------------------------------------
            <summary>
            Writes an event to the logger. This method will do nothing if Init() is not called
            first.
            </summary>
            <param name="message"></param>
            ------------------------------------------------------------------------------------
        </member>
        <member name="M:Palaso.Reporting.Logger.WriteMinorEvent(System.String,System.Object[])">
            <summary>
            only a limitted number of the most recent of these events will show up in the log
            </summary>
        </member>
        <member name="P:Palaso.Reporting.Logger.IsDisposed">
            <summary>
            See if the object has been disposed.
            </summary>
        </member>
        <member name="P:Palaso.Reporting.Logger.LogText">
            ------------------------------------------------------------------------------------
            <summary>
            Gets the entire text of the log file
            </summary>
            <returns></returns>
            ------------------------------------------------------------------------------------
        </member>
        <member name="T:Palaso.Progress.ProgressState">
            <summary>
            Long-running tasks can be written to take one of these as an argument, and use it to notify others of their progress
            </summary>
        </member>
        <member name="M:Palaso.Progress.ProgressState.CancelRequested(System.Object,System.EventArgs)">
            <summary>
            Normally, you'll wire the cancel button or whatever of the ui to this,
            then let the worker check our Cancel status in its inner loop.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="F:Palaso.Progress.ProgressState._isDisposed">
            <summary>
            True, if the object has been disposed.
            </summary>
        </member>
        <member name="M:Palaso.Progress.ProgressState.Finalize">
            <summary>
            Finalizer, in case client doesn't dispose it.
            Force Dispose(false) if not already called (i.e. _isDisposed is true)
            </summary>
            <remarks>
            In case some clients forget to dispose it directly.
            </remarks>
        </member>
        <member name="M:Palaso.Progress.ProgressState.Dispose">
            <summary>
            
            </summary>
            <remarks>Must not be virtual.</remarks>
        </member>
        <member name="M:Palaso.Progress.ProgressState.Dispose(System.Boolean)">
            <summary>
            Executes in two distinct scenarios.
            
            1. If disposing is true, the method has been called directly
            or indirectly by a user's code via the Dispose method.
            Both managed and unmanaged resources can be disposed.
            
            2. If disposing is false, the method has been called by the 
            runtime from inside the finalizer and you should not reference (access) 
            other managed objects, as they already have been garbage collected.
            Only unmanaged resources can be disposed.
            </summary>
            <param name="disposing"></param>
            <remarks>
            If any exceptions are thrown, that is fine.
            If the method is being done in a finalizer, it will be ignored.
            If it is thrown by client code calling Dispose,
            it needs to be handled by fixing the bug.
            
            If subclasses override this method, they should call the base implementation.
            </remarks>
        </member>
        <member name="P:Palaso.Progress.ProgressState.NumberOfStepsCompleted">
            <summary>
            How much the task is done
            </summary>
        </member>
        <member name="P:Palaso.Progress.ProgressState.StatusLabel">
            <summary>
            a label which describes what we are busy doing
            </summary>
        </member>
        <member name="P:Palaso.Progress.ProgressState.IsDisposed">
            <summary>
            See if the object has been disposed.
            </summary>
        </member>
        <member name="T:Palaso.CommandLineProcessing.CommandLineRunner">
            <summary>
             
            </summary>
        </member>
        <member name="T:Palaso.CommandLineProcessing.ProcessStream">
            <summary>
            This is class originally from  SeemabK (seemabk@yahoo.com).  It has been enhanced for chorus.
            </summary>
        </member>
        <member name="M:Palaso.CommandLineProcessing.ProcessOutputReader.Read(System.Diagnostics.Process@,System.Int32,Palaso.CommandLineProcessing.IProgress)">
            <summary>
            Safely read the streams of the process
            </summary>
            <param name="process"></param>
            <param name="secondsBeforeTimeOut"></param>
            <returns>true if the process completed before the timeout or cancellation</returns>
        </member>
        <member name="M:Palaso.Text.MultiTextBase.ContainsAlternative(System.String)">
            <summary>
            Throws exception if alternative does not exist.
            </summary>
            <param name="writingSystemId"></param>
            <returns></returns>
        </member>
        <member name="M:Palaso.Text.MultiTextBase.GetExactAlternative(System.String)">
            <summary>
            Get exact alternative or String.Empty
            </summary>
            <param name="writingSystemId"></param>
            <returns></returns>
        </member>
        <member name="M:Palaso.Text.MultiTextBase.GetBestAlternative(System.String)">
            <summary>
            Gives the string of the requested id if it exists, else the 'first'(?) one that does exist, else Empty String
            </summary>
            <returns></returns>
        </member>
        <member name="M:Palaso.Text.MultiTextBase.GetAlternative(System.String,System.Boolean,System.String)">
            <summary>
            Get a string out
            </summary>
            <returns>the string of the requested id if it exists, 
            else the 'first'(?) one that does exist + the suffix, 
            else the given suffix </returns>
        </member>
        <member name="M:Palaso.Text.MultiTextBase.GetBestAlternative(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Try to get an alternative according to the ws's given(e.g. the enabled writing systems for a field)
            </summary>
            <param name="orderedListOfWritingSystemIds"></param>
            <returns>May return null!</returns>
        </member>
        <member name="E:Palaso.Text.MultiTextBase.PropertyChanged">
            <summary>
            For INotifyPropertyChanged
            </summary>
        </member>
        <member name="P:Palaso.Text.MultiTextBase.Forms">
            <summary>
            just for deserialization
            </summary>
        </member>
        <member name="T:Spart.Parsers.Composite.IntersectionParser">
            <summary>
            A parser which matches when the input matches the first parser and the second parser
            </summary>
        </member>
        <member name="M:Spart.Parsers.Composite.IntersectionParser.#ctor(Spart.Parsers.Parser,Spart.Parsers.Parser)">
            <summary>
            constructor
            </summary>
            <param name="first"></param>
            <param name="second"></param>
        </member>
        <member name="M:Spart.Parsers.Composite.IntersectionParser.ParseMain(Spart.Scanners.IScanner)">
            <summary>
            Inner parse method
            </summary>
            <param name="scanner">scanner</param>
            <returns>the match</returns>
        </member>
        <member name="T:Rhino.Commons.DisposableAction`1">
            <summary>
            Better sytnax for context operation.
            Wraps a delegate that is executed when the Dispose method is called.
            This allows to do context sensitive things easily.
            Basically, it mimics Java's anonymous classes.
            </summary>
            <typeparam name="T">
            The type of the parameter that the delegate to execute on dispose
            will accept
            </typeparam>
        </member>
        <member name="M:Rhino.Commons.DisposableAction`1.#ctor(Palaso.Proc{`0},`0)">
            <summary>
            Initializes a new instance of the <see cref="T:Rhino.Commons.DisposableAction`1"/> class.
            </summary>
            <param name="action">The action to execute on dispose</param>
            <param name="val">The value that will be passed to the action on dispose</param>
        </member>
        <member name="M:Rhino.Commons.DisposableAction`1.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="P:Rhino.Commons.DisposableAction`1.Value">
            <summary>
            Gets the value associated with this action
            </summary>
            <value>The value.</value>
        </member>
        <member name="T:Rhino.Commons.DisposableAction">
            <summary>
            Better sytnax for context operation.
            Wraps a delegate that is executed when the Dispose method is called.
            This allows to do context sensitive things easily.
            Basically, it mimics Java's anonymous classes.
            </summary>
        </member>
        <member name="M:Rhino.Commons.DisposableAction.#ctor(Palaso.Proc)">
            <summary>
            Initializes a new instance of the <see cref="T:Rhino.Commons.DisposableAction"/> class.
            </summary>
            <param name="action">The action to execute on dispose</param>
        </member>
        <member name="M:Rhino.Commons.DisposableAction.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="T:Palaso.Func`1">
            <summary>
            Common delegate definition
            </summary>
            <summary>
            Common delegate definition
            </summary>
        </member>
        <member name="T:Palaso.Func`2">
            <summary>
            Common delegate definition
            </summary>
        </member>
        <member name="T:Palaso.Func`3">
            <summary>
            Common delegate definition
            </summary>
        </member>
        <member name="T:Palaso.Func`4">
            <summary>
            Common delegate definition
            </summary>
        </member>
        <member name="T:Palaso.Func`5">
            <summary>
            Common delegate definition
            </summary>
        </member>
        <member name="T:Palaso.Func`6">
            <summary>
            Common delegate definition
            </summary>
        </member>
        <member name="T:Palaso.Func`7">
            <summary>
            Common delegate definition
            </summary>
        </member>
        <member name="T:Palaso.Func`8">
            <summary>
            Common delegate definition
            </summary>
        </member>
        <member name="T:Palaso.Func`9">
            <summary>
            Common delegate definition
            </summary>
        </member>
        <member name="T:Palaso.Func`10">
            <summary>
            Common delegate definition
            </summary>
        </member>
        <member name="T:Palaso.Proc">
            <summary>
            Common delegate definition
            </summary>
        </member>
        <member name="T:Palaso.Proc`1">
            <summary>
            Common delegate definition
            </summary>
        </member>
        <member name="T:Palaso.Proc`2">
            <summary>
            Common delegate definition
            </summary>
        </member>
        <member name="T:Palaso.Proc`3">
            <summary>
            Common delegate definition
            </summary>
        </member>
        <member name="T:Palaso.Proc`4">
            <summary>
            Common delegate definition
            </summary>
        </member>
        <member name="T:Palaso.Proc`5">
            <summary>
            Common delegate definition
            </summary>
        </member>
        <member name="T:Palaso.Proc`6">
            <summary>
            Common delegate definition
            </summary>
        </member>
        <member name="T:Palaso.Proc`7">
            <summary>
            Common delegate definition
            </summary>
        </member>
        <member name="T:Palaso.Proc`8">
            <summary>
            Common delegate definition
            </summary>
        </member>
        <member name="T:Palaso.Proc`9">
            <summary>
            Common delegate definition
            </summary>
        </member>
        <member name="M:Palaso.Data.ResultSet`1.Coalesce(System.String,System.Predicate{System.Object})">
            <summary>
            Removes any entries for which the predicate canBeRemoved is true 
              and another record token with the same repository Id exists
            </summary>
            <param name="fieldName"></param>
            <param name="canBeRemoved"></param>
        </member>
        <member name="M:Palaso.WritingSystems.Collation.IcuRulesCollator.Compare(System.String,System.String)">
            <summary>Compares two strings and returns a value indicating whether one is less than, 
             equal to, or greater than the other.</summary>
            
            <returns>Less than zero when string1 is less than string2.
              Zero when string1 equals string2.
              Greater than zero when string1 is greater than string2.
            </returns>
            
            <param name="string1">The first string to compare.</param>
            <param name="string2">The second object to compare.</param>
        </member>
        <member name="T:Spart.Actions.ActionEventArgs">
            <summary>
            Action event argument class
            </summary>
        </member>
        <member name="M:Spart.Actions.ActionEventArgs.#ctor(Spart.Parsers.ParserMatch)">
            <summary>
            Construct a new event argument instance
            </summary>
            <param name="match"></param>
        </member>
        <member name="M:Spart.Actions.ActionEventArgs.#ctor(Spart.Parsers.ParserMatch,System.Object)">
            <summary>
            Construct a new event argument instance
            </summary>
            <param name="match"></param>
            <param name="typedValue"></param>
        </member>
        <member name="P:Spart.Actions.ActionEventArgs.Match">
            <summary>
            The parser match
            </summary>
        </member>
        <member name="P:Spart.Actions.ActionEventArgs.Value">
            <summary>
            The parser match value
            </summary>
        </member>
        <member name="P:Spart.Actions.ActionEventArgs.TypeValue">
            <summary>
            The typed parse result
            </summary>
        </member>
        <member name="M:Palaso.Code.ReentryDetecter.AndThrow">
            <example>
              using (Detect.Reentry(this, "OnPropertyValueChanged").AndThrow())
              {
            </example>
        </member>
        <member name="P:Palaso.Code.ReentryDetecter.DidReenter">
            <example>
              using (var x = Detect.Reentry(this, "OnPropertyValueChanged"))
              {
                    if(x.DidReenter)
                        return;
            </example>
        </member>
        <member name="F:Palaso.Text.ApproximateMatcherOptions.None">
            <summary>
            Find closest forms only
            </summary>
        </member>
        <member name="T:Spart.Parsers.Prims">
            <summary>
            Static helper class to create primitive parsers
            </summary>
        </member>
        <member name="M:Spart.Parsers.Prims.Ch(System.Char)">
            <summary>
            Creates a parser that matches a single character
            </summary>
            <param name="matchCharacter">character to match</param>
            <returns></returns>
        </member>
        <member name="M:Spart.Parsers.Prims.Str(System.String)">
            <summary>
            Creates a parser that matches a string
            </summary>
            <param name="s">string to match</param>
            <returns></returns>
        </member>
        <member name="M:Spart.Parsers.Prims.Range(System.Char,System.Char)">
            <summary>
            Creates a parser that matches a range of character
            </summary>
            <param name="first"></param>
            <param name="last"></param>
            <returns></returns>
        </member>
        <member name="M:Spart.Parsers.Prims.AnyCharTester(System.Char)">
            <summary>
            Recognizes all characters
            </summary>
            <param name="c">the character to try to recognize</param>
            <returns>always true</returns>
        </member>
        <member name="M:Spart.Parsers.Prims.HexDigitCharTester(System.Char)">
            <summary>
            Recognizes a hexadecimal digit (0..9 a..f A..F)
            </summary>
            <param name="c">the character to try to recognize</param>
            <returns>true if recognized, false if not</returns>
        </member>
        <member name="P:Spart.Parsers.Prims.AnyChar">
            <summary>
            Creates a parser that matches any character
            </summary>
        </member>
        <member name="P:Spart.Parsers.Prims.Control">
            <summary>
            Creates a parser that matches control characters
            </summary>
        </member>
        <member name="P:Spart.Parsers.Prims.Digit">
            <summary>
            Creates a parser that matches digit characters
            </summary>
        </member>
        <member name="P:Spart.Parsers.Prims.HexDigit">
            <summary>
            Creates a parser that matches hexadecimal digit characters
            </summary>
        </member>
        <member name="P:Spart.Parsers.Prims.Letter">
            <summary>
            Creates a parser that matches letter characters
            </summary>
        </member>
        <member name="P:Spart.Parsers.Prims.LetterOrDigit">
            <summary>
            Creates a parser that matches letter or digit characters
            </summary>
        </member>
        <member name="P:Spart.Parsers.Prims.Lower">
            <summary>
            Creates a parser that matches lower case characters
            </summary>
        </member>
        <member name="P:Spart.Parsers.Prims.Punctuation">
            <summary>
            Creates a parser that matches punctuation characters
            </summary>
        </member>
        <member name="P:Spart.Parsers.Prims.Separator">
            <summary>
            Creates a parser that matches separator characters
            </summary>
        </member>
        <member name="P:Spart.Parsers.Prims.Symbol">
            <summary>
            Creates a parser that matches symbol characters
            </summary>
        </member>
        <member name="P:Spart.Parsers.Prims.Upper">
            <summary>
            Creates a parser that matches upper case characters
            </summary>
        </member>
        <member name="P:Spart.Parsers.Prims.WhiteSpace">
            <summary>
            Creates a parser that matches whitespace characters
            </summary>
        </member>
        <member name="P:Spart.Parsers.Prims.Eol">
            <summary>
            Creates a parser that matches and end of line
            </summary>
        </member>
        <member name="P:Spart.Parsers.Prims.End">
            <summary>
            Creates a parser that matches the end of the input
            </summary>
        </member>
        <member name="T:Spart.Parsers.Primitives.NothingParser">
            <summary>
            Recognizes nothing (always returns no match)
            </summary>
        </member>
        <member name="M:Spart.Parsers.Primitives.NothingParser.ParseMain(Spart.Scanners.IScanner)">
            <summary>
            Inner parse method
            </summary>
            <param name="scanner">scanner</param>
            <returns>the match</returns>
        </member>
        <member name="T:Spart.Parsers.NonTerminal.IParserContext">
            <summary>
            a parser context
            </summary>
        </member>
        <member name="M:Spart.Parsers.NonTerminal.IParserContext.PreParse(System.Object,Spart.Parsers.NonTerminal.PreParseEventArgs)">
            <summary>
            handle the preparse event
            </summary>
            <param name="sender"></param>
            <param name="args"></param>
        </member>
        <member name="M:Spart.Parsers.NonTerminal.IParserContext.PostParse(System.Object,Spart.Parsers.NonTerminal.PostParseEventArgs)">
            <summary>
            handle the postparse event
            </summary>
            <param name="sender"></param>
            <param name="args"></param>
        </member>
        <member name="T:Spart.Parsers.NonTerminal.AssertiveParser">
            <summary>
            An AssertiveParser is a parser holder that throws an exception
                 in response to a parsing failure.
            </summary>
            <remarks>The parsing failure is determined by the AssertDelegate which defaults
            to asserting on match failure.</remarks>
        </member>
        <member name="T:Spart.Parsers.NonTerminal.NonTerminalParser">
            <summary>
            NonTerminal parser abstract class
            </summary>
        </member>
        <member name="M:Spart.Parsers.NonTerminal.NonTerminalParser.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Spart.Parsers.NonTerminal.NonTerminalParser.OnPreParse(Spart.Scanners.IScanner)">
            <summary>
            Preparse event caller
            </summary>
            <param name="scan"></param>
        </member>
        <member name="M:Spart.Parsers.NonTerminal.NonTerminalParser.OnPostParse(Spart.Parsers.ParserMatch,Spart.Scanners.IScanner)">
            <summary>
            Post parse event caller
            </summary>
            <param name="match"></param>
            <param name="scan"></param>
        </member>
        <member name="M:Spart.Parsers.NonTerminal.NonTerminalParser.AddContext(Spart.Parsers.NonTerminal.IParserContext)">
            <summary>
            Adds event handlers
            </summary>
            <param name="context"></param>
        </member>
        <member name="M:Spart.Parsers.NonTerminal.NonTerminalParser.RemoveContext(Spart.Parsers.NonTerminal.IParserContext)">
            <summary>
            Removes event handlers
            </summary>
            <param name="context"></param>
        </member>
        <member name="P:Spart.Parsers.NonTerminal.NonTerminalParser.ID">
            <summary>
            Rule ID, used for debugging
            </summary>
        </member>
        <member name="E:Spart.Parsers.NonTerminal.NonTerminalParser.PreParse">
            <summary>
            Pre parse event
            </summary>
        </member>
        <member name="E:Spart.Parsers.NonTerminal.NonTerminalParser.PostParse">
            <summary>
            Post parse event 
            </summary>
        </member>
        <member name="P:Spart.Parsers.NonTerminal.AssertiveParser.Parser">
            <summary>
            Wrapped parser
            </summary>
        </member>
        <member name="P:Spart.Parsers.NonTerminal.AssertiveParser.Assert">
            <summary>
            validator
            </summary>
        </member>
        <member name="T:Spart.Actions.ActionHandlers">
            <summary>
            Static helper class that creates actors
            </summary>
        </member>
        <member name="M:Spart.Actions.ActionHandlers.Append(System.Collections.IList)">
            <summary>
            Create an actor that append the parse result to a <see cref="T:System.Collections.IList"/>.
            </summary>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:Spart.Actions.ActionHandlers.Throw(System.Exception)">
            <summary>
            Creates an actor that throws an exception
            </summary>
            <param name="ex"></param>
            <returns></returns>
        </member>
        <member name="M:Palaso.Reporting.UsageReporter.RecordLaunch">
            <summary>
            call this each time the application is launched
            </summary>
        </member>
        <member name="M:Palaso.Reporting.UsageReporter.MakeLaunchDateSafe">
            <summary>
            cover an apparent bug in the generated code when you do a get but the datetime is null
            </summary>
        </member>
        <member name="M:Palaso.Reporting.UsageReporter.ResetSettingsForTests">
            <summary>
            used for testing purposes
            </summary>
        </member>
        <member name="M:Palaso.Reporting.UsageReporter.DoTrivialUsageReport(System.String,System.String,System.Int32[])">
            <summary>
            if you call this every time the application starts, it will send reports on those intervals
            (e.g. {1, 10}) that are listed in the intervals parameter.  It will get version number and name out of the application.
            </summary>
        </member>
        <member name="P:Palaso.Reporting.UsageReporter.AppReportingSettings">
            <summary>
            The deal here is, Cambell changed this so that it is the responsibility of
            the client to set this, and then save the settings.
            E.g., in the Settings.Designer.cs, add
            
                [UserScopedSetting()]
            	[DebuggerNonUserCode()]
            	public Palaso.Reporting.ReportingSettings Reporting
            	{
            		get { return ((Palaso.Reporting.ReportingSettings)(this["Reporting"])); }
            		set { this["Reporting"] = value; }
            	}
            </summary>
        </member>
        <member name="M:Palaso.Reporting.ExceptionHandler.HandleUnhandledException(System.Object,System.UnhandledExceptionEventArgs)">
            ------------------------------------------------------------------------------------
            <summary>
            Catches and displays otherwise unhandled exception, especially those that happen
            during startup of the application before we show our main window.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
            ------------------------------------------------------------------------------------
        </member>
        <member name="M:Palaso.Reporting.ExceptionHandler.HandleTopLevelError(System.Object,System.Threading.ThreadExceptionEventArgs)">
            ------------------------------------------------------------------------------------
            <summary>
            Catches and displays a otherwise unhandled exception.
            </summary>
            <param name="sender">sender</param>
            <param name="eventArgs">Exception</param>
            <remarks>previously <c>AfApp::HandleTopLevelError</c></remarks>
            ------------------------------------------------------------------------------------
        </member>
        <member name="M:Palaso.Reporting.ExceptionHandler.DisplayError(System.Exception)">
            ------------------------------------------------------------------------------------
            <summary>
            Displays the error.
            </summary>
            <param name="exception">The exception.</param>
            <returns></returns>
            ------------------------------------------------------------------------------------
        </member>
        <member name="P:Palaso.Reporting.ExceptionHandler.ShowUI">
            ------------------------------------------------------------------------------------
            <summary>
            Gets the setting for displaying error message boxes. The value is retrieved from
            the .config file.
            </summary>
            <remarks>
            To disable displaying an error message box, put
            <code>&lt;add key="ShowUI" value="False"/></code>
            in the &lt;appSettings> section of the .config file (see MSDN for details).
            </remarks>
            ------------------------------------------------------------------------------------
        </member>
        <member name="P:Palaso.Email.EmailMessage.Subject">
            <summary>
            the  e-mail subject
            </summary>
        </member>
        <member name="P:Palaso.Email.EmailMessage.Body">
            <summary>
            
            </summary>
        </member>
        <member name="T:Palaso.Code.RequireThat">
            <summary>
            Allows statements like:
            	RequireThat.Directory(dir).Exists();
            	RequireThat.Directory(dir).DoesNotExist();
            	RequireThat.File(path).DoesNotExist();
            	RequireThat.File(path).Directory.Exists();
            </summary>
        </member>
        <member name="P:Palaso.Code.RequireThat.FileChecker.Directory">
            <summary>
            Allows us to say RequireThat.File("foo/blah.txt").Directory.Exists();
            </summary>
            <returns></returns>
        </member>
        <member name="M:Palaso.WritingSystems.IWritingSystemStore.Set(Palaso.WritingSystems.WritingSystemDefinition)">
            <summary>
            Adds the writing system to the store or updates the store information about
            an already-existing writing system.  Set should be called when there is a change
            that updates the RFC5646 information.
            </summary>
        </member>
        <member name="M:Palaso.WritingSystems.IWritingSystemStore.CanSet(Palaso.WritingSystems.WritingSystemDefinition)">
            <summary>
            Returns true if a call to Set should succeed, false if a call to Set would throw
            </summary>
        </member>
        <member name="M:Palaso.WritingSystems.IWritingSystemStore.Get(System.String)">
            <summary>
            Gets the writing system object for the given Store ID
            </summary>
        </member>
        <member name="M:Palaso.WritingSystems.IWritingSystemStore.GetNewStoreIDWhenSet(Palaso.WritingSystems.WritingSystemDefinition)">
            <summary>
            If the given writing system were passed to Set, this function returns the
            new StoreID that would be assigned.
            </summary>
        </member>
        <member name="M:Palaso.WritingSystems.IWritingSystemStore.Exists(System.String)">
            <summary>
            Returns true if a writing system with the given Store ID exists in the store
            </summary>
        </member>
        <member name="M:Palaso.WritingSystems.IWritingSystemStore.CreateNew">
            <summary>
            Creates a new writing system object and returns it.  Set will need to be called
            once identifying information has been changed in order to save it in the store.
            </summary>
        </member>
        <member name="M:Palaso.WritingSystems.IWritingSystemStore.Remove(System.String)">
            <summary>
            Removes the writing system with the specified Store ID from the store.
            </summary>
        </member>
        <member name="M:Palaso.WritingSystems.IWritingSystemStore.MakeDuplicate(Palaso.WritingSystems.WritingSystemDefinition)">
            <summary>
            Makes a duplicate of an existing writing system definition.  Set will need
            to be called with this new duplicate once identifying information has been changed
            in order to place the new definition in the store.
            </summary>
        </member>
        <member name="M:Palaso.WritingSystems.IWritingSystemStore.Save">
            <summary>
            Writes the store to a persistable medium, if applicable.
            </summary>
        </member>
        <member name="M:Palaso.WritingSystems.IWritingSystemStore.WritingSystemsNewerIn(System.Collections.Generic.IEnumerable{Palaso.WritingSystems.WritingSystemDefinition})">
            <summary>
            Returns a list of writing systems from rhs which are newer than ones in the store.
            </summary>
        </member>
        <member name="P:Palaso.WritingSystems.IWritingSystemStore.Count">
            <summary>
            Gives the total number of writing systems in the store
            </summary>
        </member>
        <member name="P:Palaso.WritingSystems.IWritingSystemStore.WritingSystemDefinitions">
            <summary>
            Returns a list of all writing system definitions in the store.
            </summary>
        </member>
        <member name="M:Palaso.IO.SFMReader.#ctor(System.String)">
            <summary>
            Construct a new SFMReader with filename
            </summary>
            <param name="fname"></param>
        </member>
        <member name="M:Palaso.IO.SFMReader.#ctor(System.IO.Stream)">
            <summary>
            Construct a new SFMReader with stream
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:Palaso.IO.SFMReader.ReadNextTag">
            <summary>
            Read next tag and return the name only (exclude backslash
            and space).
            </summary>
            <returns>next tag name</returns>
        </member>
        <member name="M:Palaso.IO.SFMReader.ReadNextText">
            <summary>
            Read next text block from stream
            </summary>
            <returns>Next text</returns>
        </member>
        <member name="M:Palaso.Xml.XmlNodeExtensions.SafeSelectNodes(System.Xml.XmlNode,System.String,System.Xml.XmlNamespaceManager)">
            <summary>
            this is safe to use with foreach, unlike SelectNodes
            </summary>
        </member>
        <member name="M:Palaso.Xml.XmlNodeExtensions.SafeSelectNodes(System.Xml.XmlNode,System.String)">
            <summary>
            honors default namespace and will return an empty list rather than null
            </summary>
        </member>
        <member name="M:Palaso.Xml.XmlHelpers.GetOptionalBooleanAttributeValue(System.Xml.XmlNode,System.String,System.Boolean)">
            <summary>
            Get an optional attribute value from an XmlNode.
            </summary>
            <param name="node">The XmlNode to look in.</param>
            <param name="attrName">The attribute to find.</param>
            <param name="defaultValue"></param>
            <returns>The value of the attribute, or the default value, if the attribute dismissing</returns>
        </member>
        <member name="M:Palaso.Xml.XmlHelpers.GetBooleanAttributeValue(System.Xml.XmlNode,System.String)">
            <summary>
            Returns true if value of attrName is 'true' or 'yes' (case ignored)
            </summary>
            <param name="node">The XmlNode to look in.</param>
            <param name="attrName">The optional attribute to find.</param>
            <returns></returns>
        </member>
        <member name="M:Palaso.Xml.XmlHelpers.GetBooleanAttributeValue(System.String)">
            <summary>
            Returns true if sValue is 'true' or 'yes' (case ignored)
            </summary>
        </member>
        <member name="M:Palaso.Xml.XmlHelpers.GetAttributeValue(System.Xml.XmlNode,System.String,System.String)">
            <summary>
            Deprecated: use GetOptionalAttributeValue instead.
            </summary>
            <param name="node"></param>
            <param name="attrName"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Palaso.Xml.XmlHelpers.GetAttributeValue(System.Xml.XmlNode,System.String)">
            <summary>
            Get an optional attribute value from an XmlNode.
            </summary>
            <param name="node">The XmlNode to look in.</param>
            <param name="attrName">The attribute to find.</param>
            <returns>The value of the attribute, or null, if not found.</returns>
        </member>
        <member name="M:Palaso.Xml.XmlHelpers.GetOptionalAttributeValue(System.Xml.XmlNode,System.String)">
            <summary>
            Get an optional attribute value from an XmlNode.
            </summary>
            <param name="node">The XmlNode to look in.</param>
            <param name="attrName">The attribute to find.</param>
            <returns>The value of the attribute, or null, if not found.</returns>
        </member>
        <member name="M:Palaso.Xml.XmlHelpers.GetOptionalAttributeValue(System.Xml.XmlNode,System.String,System.String)">
            <summary>
            Get an optional attribute value from an XmlNode.
            </summary>
            <param name="node">The XmlNode to look in.</param>
            <param name="attrName">The attribute to find.</param>
            <returns>The value of the attribute, or null, if not found.</returns>
        </member>
        <member name="M:Palaso.WritingSystems.WritingSystemStoreBase.#ctor">
            <summary>
            Use the default repository
            </summary>
        </member>
        <member name="M:Palaso.WritingSystems.LdmlInXmlWritingSystemStore.#ctor">
            <summary>
            Use the default repository
            </summary>
        </member>
        <member name="T:Spart.Scanners.StringScanner">
            <summary>
            Scanner acting on a string.
            <seealso cref="T:Spart.Scanners.IScanner"/>
            </summary>
        </member>
        <member name="T:Spart.Scanners.IScanner">
            <summary>
            Input scanner interface
            </summary>
        </member>
        <member name="M:Spart.Scanners.IScanner.Read">
            <summary>
            Reads one character of the input
            </summary>
            <returns>true if not at end</returns>
        </member>
        <member name="M:Spart.Scanners.IScanner.Peek">
            <summary>
            Current character
            </summary>
            <returns></returns>
        </member>
        <member name="M:Spart.Scanners.IScanner.Seek(System.Int64)">
            <summary>
            Move cursor position to the offset
            </summary>
            <param name="offset"></param>
        </member>
        <member name="M:Spart.Scanners.IScanner.Substring(System.Int64,System.Int32)">
            <summary>
            Extracts a substring of the input
            </summary>
            <param name="offset"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="P:Spart.Scanners.IScanner.AtEnd">
            <summary>
            Return true if all input is consummed
            </summary>
        </member>
        <member name="P:Spart.Scanners.IScanner.Offset">
            <summary>
            Scanner cursor position
            </summary>
        </member>
        <member name="P:Spart.Scanners.IScanner.Filter">
            <summary>
            Sets the input filter
            </summary>
        </member>
        <member name="M:Spart.Scanners.StringScanner.#ctor(System.String)">
            <summary>
            Creates a scanner on the string.
            </summary>
            <param name="inputString">Input string</param>
            <exception cref="T:System.ArgumentNullException">input string is null</exception>
        </member>
        <member name="M:Spart.Scanners.StringScanner.#ctor(System.String,System.Int64)">
            <summary>
            Creates a scanner on the string at a specified offset
            </summary>
            <param name="inputString">Input string</param>
            <param name="offset">start position for scanner</param>
            <exception cref="T:System.ArgumentNullException">input string is null</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">offset if out of range</exception>
        </member>
        <member name="M:Spart.Scanners.StringScanner.Read">
            <summary>
            Advance the cursor once
            </summary>
            <returns>true if not at end</returns>
            <exception cref="T:System.InvalidOperationException">If called while AtEnd is true</exception>
        </member>
        <member name="M:Spart.Scanners.StringScanner.Peek">
            <summary>
            Current character
            </summary>
            <returns>character at cursor position</returns>
        </member>
        <member name="M:Spart.Scanners.StringScanner.Substring(System.Int64,System.Int32)">
            <summary>
            Extracts a substring 
            </summary>
            <param name="offset"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:Spart.Scanners.StringScanner.Seek(System.Int64)">
            <summary>
            Moves the cursor to the offset position
            </summary>
            <param name="offset"></param>
        </member>
        <member name="P:Spart.Scanners.StringScanner.InputString">
            <summary>
            the input string
            </summary>
        </member>
        <member name="P:Spart.Scanners.StringScanner.Offset">
            <summary>
            Current offset
            </summary>
        </member>
        <member name="P:Spart.Scanners.StringScanner.AtEnd">
            <summary>
            true if at the end of the string
            </summary>
        </member>
        <member name="P:Spart.Scanners.StringScanner.Filter">
            <summary>
            Current filter
            </summary>
        </member>
        <member name="T:Spart.Parsers.Primitives.StringParser">
            <summary>
            Matches a given string
            </summary>
        </member>
        <member name="M:Spart.Parsers.Primitives.StringParser.#ctor(System.String)">
            <summary>
            constructor
            </summary>
            <param name="str">The string to match</param>
        </member>
        <member name="M:Spart.Parsers.Primitives.StringParser.ParseMain(Spart.Scanners.IScanner)">
            <summary>
            Inner parse method
            </summary>
            <param name="scanner">scanner</param>
            <returns>the match</returns>
        </member>
        <member name="P:Spart.Parsers.Primitives.StringParser.MatchedString">
            <summary>
            the string to match
            </summary>
        </member>
        <member name="T:Spart.Parsers.Primitives.Testers.CharRecognizer">
            <summary>
            A Delegate for testing whether a character should be recognized
            </summary>
            <param name="c">The character to be tested</param>
            <returns>true when the character is recognized, false when it is not</returns>
        </member>
        <member name="T:Spart.Parsers.NonTerminal.PostParseEventHandler">
            <summary>
            Delegate for handling PostParse Events
            </summary>
            <param name="sender"></param>
            <param name="args"></param>
        </member>
        <member name="F:Palaso.Reporting.UserRegistrationDialog.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:Palaso.Reporting.UserRegistrationDialog.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:Palaso.Reporting.UserRegistrationDialog.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="F:Palaso.Base32.Base32FormattingOptions.None">
            <summary>
            Does not insert '=' at end of the string to pad it so that the string length is a multiple
            of 8
            </summary>
        </member>
        <member name="F:Palaso.Base32.Base32FormattingOptions.InsertTrailingPadding">
            <summary>
            Inserts '=' at the end of the string to pad it so that the string length is a multiple
            of 8
            </summary>
        </member>
        <member name="T:Palaso.Xml.XmlUtils">
            <summary>
            Summary description for XmlUtils.
            </summary>
        </member>
        <member name="M:Palaso.Xml.XmlUtils.GetBooleanAttributeValue(System.Xml.XmlNode,System.String)">
            <summary>
            Returns true if value of attrName is 'true' or 'yes' (case ignored)
            </summary>
            <param name="node">The XmlNode to look in.</param>
            <param name="attrName">The optional attribute to find.</param>
            <returns></returns>
        </member>
        <member name="M:Palaso.Xml.XmlUtils.GetBooleanAttributeValue(System.Xml.XPath.XPathNavigator,System.String)">
            <summary>
            Returns true if value of attrName is 'true' or 'yes' (case ignored)
            </summary>
            <param name="node">The XmlNode to look in.</param>
            <param name="attrName">The optional attribute to find.</param>
            <returns></returns>
        </member>
        <member name="M:Palaso.Xml.XmlUtils.GetBooleanAttributeValue(System.String)">
            <summary>
            Returns true if sValue is 'true' or 'yes' (case ignored)
            </summary>
        </member>
        <member name="M:Palaso.Xml.XmlUtils.GetMandatoryIntegerAttributeValue(System.Xml.XmlNode,System.String)">
            <summary>
            Returns a integer obtained from the (mandatory) attribute named.
            </summary>
            <param name="node">The XmlNode to look in.</param>
            <param name="attrName">The mandatory attribute to find.</param>
            <returns>The value, or 0 if attr is missing.</returns>
        </member>
        <member name="M:Palaso.Xml.XmlUtils.GetOptionalIntegerValue(System.Xml.XmlNode,System.String,System.Int32)">
            <summary>
            Return an optional integer attribute value, or if not found, the default value.
            </summary>
            <param name="node"></param>
            <param name="attrName"></param>
            <param name="defaultVal"></param>
            <returns></returns>
        </member>
        <member name="M:Palaso.Xml.XmlUtils.GetMandatoryIntegerListAttributeValue(System.Xml.XmlNode,System.String)">
            <summary>
            Retrieve an array, given an attribute consisting of a comma-separated list of integers
            </summary>
            <param name="node"></param>
            <param name="attrName"></param>
            <returns></returns>
        </member>
        <member name="M:Palaso.Xml.XmlUtils.MakeIntegerListValue(System.Int32[])">
            <summary>
            Make a value suitable for GetMandatoryIntegerListAttributeValue to parse.
            </summary>
            <param name="vals"></param>
            <returns></returns>
        </member>
        <member name="M:Palaso.Xml.XmlUtils.MakeListValue(System.Collections.Generic.List{System.Int32})">
            <summary>
            Make a comma-separated list of the ToStrings of the values in the list.
            </summary>
            <param name="vals"></param>
            <returns></returns>
        </member>
        <member name="M:Palaso.Xml.XmlUtils.GetOptionalBooleanAttributeValue(System.Xml.XmlNode,System.String,System.Boolean)">
            <summary>
            Get an optional attribute value from an XmlNode.
            </summary>
            <param name="node">The XmlNode to look in.</param>
            <param name="attrName">The attribute to find.</param>
            <param name="defaultValue"></param>
            <returns>The value of the attribute, or the default value, if the attribute dismissing</returns>
        </member>
        <member name="M:Palaso.Xml.XmlUtils.GetAttributeValue(System.Xml.XmlNode,System.String,System.String)">
            <summary>
            Deprecated: use GetOptionalAttributeValue instead.
            </summary>
            <param name="node"></param>
            <param name="attrName"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Palaso.Xml.XmlUtils.GetAttributeValue(System.Xml.XmlNode,System.String)">
            <summary>
            Get an optional attribute value from an XmlNode.
            </summary>
            <param name="node">The XmlNode to look in.</param>
            <param name="attrName">The attribute to find.</param>
            <returns>The value of the attribute, or null, if not found.</returns>
        </member>
        <member name="M:Palaso.Xml.XmlUtils.GetOptionalAttributeValue(System.Xml.XmlNode,System.String)">
            <summary>
            Get an optional attribute value from an XmlNode.
            </summary>
            <param name="node">The XmlNode to look in.</param>
            <param name="attrName">The attribute to find.</param>
            <returns>The value of the attribute, or null, if not found.</returns>
        </member>
        <member name="M:Palaso.Xml.XmlUtils.GetOptionalAttributeValue(System.Xml.XPath.XPathNavigator,System.String)">
            <summary>
            Get an optional attribute value from an XmlNode.
            </summary>
            <param name="node">The XmlNode to look in.</param>
            <param name="attrName">The attribute to find.</param>
            <returns>The value of the attribute, or null, if not found.</returns>
        </member>
        <member name="M:Palaso.Xml.XmlUtils.GetOptionalAttributeValue(System.Xml.XmlNode,System.String,System.String)">
            <summary>
            Get an optional attribute value from an XmlNode.
            </summary>
            <param name="node">The XmlNode to look in.</param>
            <param name="attrName">The attribute to find.</param>
            <returns>The value of the attribute, or null, if not found.</returns>
            <param name="defaultString"></param>
        </member>
        <member name="M:Palaso.Xml.XmlUtils.GetOptionalAttributeValue(System.Xml.XPath.XPathNavigator,System.String,System.String)">
            <summary>
            Get an optional attribute value from an XmlNode.
            </summary>
            <param name="node">The XmlNode to look in.</param>
            <param name="attrName">The attribute to find.</param>
            <returns>The value of the attribute, or null, if not found.</returns>
            <param name="defaultString"></param>
        </member>
        <member name="M:Palaso.Xml.XmlUtils.FindNode(System.Xml.XmlNode,System.String)">
            <summary>
            Return the node that has the desired 'name', either the input node or a decendent.
            </summary>
            <param name="node">The XmlNode to look in.</param>
            <param name="name">The XmlNode name to find.</param>
            <returns></returns>
        </member>
        <member name="M:Palaso.Xml.XmlUtils.GetManditoryAttributeValue(System.Xml.XmlNode,System.String)">
            <summary>
            Get an obligatory attribute value.
            </summary>
            <param name="node">The XmlNode to look in.</param>
            <param name="attrName">The required attribute to find.</param>
            <returns>The value of the attribute.</returns>
            <exception cref="T:System.ApplicationException">
            Thrown when the value is not found in the node.
            </exception>
        </member>
        <member name="M:Palaso.Xml.XmlUtils.AppendAttribute(System.Xml.XmlNode,System.String,System.String)">
            <summary>
            Append an attribute with the specified name and value to parent.
            </summary>
            <param name="parent"></param>
            <param name="attrName"></param>
            <param name="attrVal"></param>
        </member>
        <member name="M:Palaso.Xml.XmlUtils.NodesMatch(System.Xml.XmlNode,System.Xml.XmlNode)">
            <summary>
            Return true if the two nodes match. Corresponding children should match, and
            corresponding attributes (though not necessarily in the same order).
            The nodes are expected to be actually XmlElements; not tested for other cases.
            Comments do not affect equality.
            </summary>
            <param name="node1"></param>
            <param name="node2"></param>
            <returns></returns>
        </member>
        <member name="M:Palaso.Xml.XmlUtils.GetFirstNonCommentChild(System.Xml.XmlNode)">
            <summary>
            Return the first child of the node that is not a comment (or null).
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="M:Palaso.Xml.XmlUtils.MakeSafeXml(System.String)">
            <summary>
            Fix the string to be safe in a text region of XML.
            </summary>
            <param name="sInput"></param>
            <returns></returns>
        </member>
        <member name="M:Palaso.Xml.XmlUtils.MakeSafeXmlAttribute(System.String)">
            <summary>
            Fix the string to be safe in an attribute value of XML.
            </summary>
            <param name="sInput"></param>
            <returns></returns>
        </member>
        <member name="M:Palaso.Xml.XmlUtils.GetIndendentedXml(System.String)">
            <summary>
            lifted from http://www.knowdotnet.com/articles/indentxml.html
            </summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="T:Spart.Parsers.Primitives.EolParser">
            <summary>
            Matches a CR, LF, or CR LF
            </summary>
        </member>
        <member name="M:Spart.Parsers.Primitives.EolParser.ParseMain(Spart.Scanners.IScanner)">
            <summary>
            Inner parse method
            </summary>
            <param name="scanner">scanner</param>
            <returns>the match</returns>
        </member>
        <member name="T:Spart.Parsers.Primitives.EndParser">
            <summary>
            Matches the eof
            </summary>
        </member>
        <member name="M:Spart.Parsers.Primitives.EndParser.ParseMain(Spart.Scanners.IScanner)">
            <summary>
            Inner parse method
            </summary>
            <param name="scanner">scanner</param>
            <returns>the match</returns>
        </member>
        <member name="T:Spart.Parsers.NonTerminal.PreParseEventArgs">
            <summary>
            Summary description for PostParseEventArgs.
            </summary>
        </member>
        <member name="M:Spart.Parsers.NonTerminal.PreParseEventArgs.#ctor(Spart.Parsers.NonTerminal.NonTerminalParser,Spart.Scanners.IScanner)">
            <summary>
            construct a preparse event args from parser and scanner
            </summary>
            <param name="parser"></param>
            <param name="scanner"></param>
        </member>
        <member name="P:Spart.Parsers.NonTerminal.PreParseEventArgs.Parser">
            <summary>
            Current parser
            </summary>
        </member>
        <member name="P:Spart.Parsers.NonTerminal.PreParseEventArgs.Scanner">
            <summary>
            current scanner
            </summary>
        </member>
        <member name="M:Palaso.WritingSystems.Collation.SimpleRulesCollator.Compare(System.String,System.String)">
            <summary>Compares two strings and returns a value indicating whether one is less than, 
             equal to, or greater than the other.</summary>
            
            <returns>Less than zero when string1 is less than string2.
              Zero when string1 equals string2.
              Greater than zero when string1 is greater than string2.
            </returns>
            
            <param name="string1">The first string to compare.</param>
            <param name="string2">The second object to compare.</param>
        </member>
        <member name="M:Palaso.WritingSystems.Collation.SimpleRulesCollator.SimpleCollationRuleParser.IsCharacter(System.Char)">
            <summary>
            Check whether the given character should be recognized
            </summary>
            <param name="c">the character to try to recognize</param>
            <returns>true if recognized, false if not</returns>
        </member>
        <member name="M:Palaso.WritingSystems.Collation.SimpleRulesCollator.SimpleCollationRuleParser.#ctor">
            <summary>
            A very simple calculator parser
            </summary>
        </member>
        <member name="M:Palaso.WritingSystems.Collation.SimpleRulesCollator.SimpleCollationRuleParser.ConvertToIcuTailoringRule(System.String)">
            <summary>
            Parse a string and return parse match
            </summary>
            <param name="rules"></param>
            <returns></returns>
        </member>
        <member name="T:Spart.Parsers.Composite.SequenceParser">
            <summary>
            matches a sequence of parsers
            </summary>
        </member>
        <member name="M:Spart.Parsers.Composite.SequenceParser.#ctor(Spart.Parsers.Parser,Spart.Parsers.Parser)">
            <summary>
            constructor
            </summary>
            <param name="first">the first parser to match</param>
            <param name="second">the next parser to match</param>
        </member>
        <member name="M:Spart.Parsers.Composite.SequenceParser.ParseMain(Spart.Scanners.IScanner)">
            <summary>
            Inner parse method
            </summary>
            <param name="scanner">scanner</param>
            <returns>the match</returns>
        </member>
        <member name="T:Palaso.Progress.AsyncCommand">
            <summary>
            An abstract base for an implementation of a command that will spawn a long operation
            </summary>
            <remarks>
            You should override the <see cref="M:Palaso.Progress.AsyncCommand.BeginInvokeCore"/> method to 
            invoke your operation using whichever asynchronous mechanism you prefer
            </remarks>
        </member>
        <member name="M:Palaso.Progress.AsyncCommand.#ctor">
            <summary>
            Standard constructor, protected because this is an abstract
            class
            </summary>
        </member>
        <member name="M:Palaso.Progress.AsyncCommand.BeginInvoke">
            <summary>
            Asynchronously executes the operation, returning immediately.
            </summary>
            <returns>
            Returns false if the operation was not <see cref="P:Palaso.Progress.AsyncCommand.Enabled"/>
            when we called the method, otherwise true.
            </returns>
            <remarks>
            The method automatically disables the operation once it is
            running, to prevent it accidentally being started again. It should
            only be called from the UI thread.
            </remarks>
        </member>
        <member name="M:Palaso.Progress.AsyncCommand.Cancel">
            <summary>
            Begin an attempt to cancel the operation
            </summary>
            <remarks>This should only be called from the UI thread</remarks>
        </member>
        <member name="M:Palaso.Progress.AsyncCommand.BeginInvokeCore">
            <summary>
            Override this method to invoke the actual
            long operation using your preferred async mode.
            </summary>
        </member>
        <member name="M:Palaso.Progress.AsyncCommand.OnFinish(System.EventArgs)">
            <summary>
            Raises the Finish event.
            </summary>
            <param name="e">Event data</param>
        </member>
        <member name="M:Palaso.Progress.AsyncCommand.OnError(Palaso.Progress.ErrorEventArgs)">
            <summary>
            Raises the Error event
            </summary>
            <param name="e">Event data</param>
        </member>
        <member name="P:Palaso.Progress.AsyncCommand.Enabled">
            <summary>
            This property can be used to enable/disable
            the command, and should be called only from 
            the UI thread
            </summary>
        </member>
        <member name="E:Palaso.Progress.AsyncCommand.EnabledChanged">
            <summary>
            Raised when the command is enabled and disabled
            </summary>
        </member>
        <member name="P:Palaso.Progress.AsyncCommand.Canceling">
            <summary>
            Gets a value which determines whether the operation is being cancelled
            </summary>
            <remarks>
            This may be called either from the UI, or by derived classes from the worker thread
            </remarks>
        </member>
        <member name="E:Palaso.Progress.AsyncCommand.BeginCancel">
            <summary>
            Raised when a cancel request is raised.
            </summary>
            <remarks>This will only be raised on the UI
            thread. Note that the operation may already have completed by the
            time the cancel event is raised, but you are guaranteed not to
            receive a <see cref="E:Palaso.Progress.AsyncCommand.Finish"/> or <see cref="E:Palaso.Progress.AsyncCommand.Error"/> event between a call to <see cref="M:Palaso.Progress.AsyncCommand.Cancel"/>
            and the BeginCancel event itself.
            </remarks> 
        </member>
        <member name="E:Palaso.Progress.AsyncCommand.Finish">
            <summary>
            Raised when the operation has finished
            </summary>
            <remarks>
            This will be raised on the worker thread, not the GUI thread. There are guaranteed to be
            no further events from the command after this event has been raised.
            </remarks>
        </member>
        <member name="E:Palaso.Progress.AsyncCommand.Error">
            <summary>
            Raised when the operation has finished, and an exception has ocurred
            </summary>
            <remarks>This will be raised on the worker thread, not the GUI thread. There are guaranteed to be
            no further events from the command after this event has been raised.</remarks>
        </member>
        <member name="T:Palaso.Progress.ErrorEventHandler">
            <summary>
            Delegate for the <see cref="E:Palaso.Progress.AsyncCommand.Error"/> event
            </summary>
        </member>
        <member name="T:Palaso.Progress.ErrorEventArgs">
            <summary>
            Class to contain the event data for the error event
            </summary>
        </member>
        <member name="M:Palaso.Progress.ErrorEventArgs.#ctor(System.Exception)">
            <summary>
            Standard constructor
            </summary>
            <param name="exception">The exception that ocurred, or null if an unspecified error ocurred</param>
        </member>
        <member name="P:Palaso.Progress.ErrorEventArgs.Exception">
            <summary>
            Gets the exception that occurred, or null if there was an unspecified error
            </summary>
        </member>
        <member name="M:Palaso.CommandLineProcessing.ConsoleProgress.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:Palaso.CommandLineProcessing.LabelStatus">
            <summary>
            Just conveys status, not all messages
            </summary>
        </member>
        <member name="T:Palaso.WritingSystems.WritingSystemDefinition">
            <summary>
            This class stores the information used to define various writing system properties.
            </summary>
        </member>
        <member name="F:Palaso.WritingSystems.WritingSystemDefinition._scriptOptions">
            <summary>
            singleton
            </summary>
        </member>
        <member name="F:Palaso.WritingSystems.WritingSystemDefinition._languageCodes">
            <summary>
            singleton
            </summary>
        </member>
        <member name="M:Palaso.WritingSystems.WritingSystemDefinition.#ctor">
            <summary>
            For overridding the other identifier fields, to specify a custom RFC5646
            </summary>
        </member>
        <member name="M:Palaso.WritingSystems.WritingSystemDefinition.LoadScriptOptionsIfNeeded">
            <summary>
            parse in the text of the script registry we get from http://unicode.org/iso15924/iso15924-text.html
            </summary>
        </member>
        <member name="M:Palaso.WritingSystems.WritingSystemDefinition.ValidateCollationRules(System.String@)">
            <summary>
            Tests whether the current custom collation rules are valid.
            </summary>
            <param name="message">Used for an error message if rules do not validate.</param>
            <returns>True if rules are valid, false otherwise.</returns>
        </member>
        <member name="P:Palaso.WritingSystems.WritingSystemDefinition.LanguageCodes">
            <summary>
            Provides a list of ISO language codes.  Uses ISO 639-1 and 639-3 where ISO 639-1 is not available.
            </summary>
        </member>
        <member name="P:Palaso.WritingSystems.WritingSystemDefinition.IpaStatus">
            <summary>
            Note: this treats the etic and emic extensions as if they were variants, which we can get 
            away with for now, but maybe not if this class grows to be extension aware.
            Ideally, these should be suffixes rather than private use
            </summary>
        </member>
        <member name="P:Palaso.WritingSystems.WritingSystemDefinition.Variant">
            <summary>
            Todo: this could/should become an ordered list of variant tags
            </summary>
        </member>
        <member name="P:Palaso.WritingSystems.WritingSystemDefinition.StoreID">
            <summary>
            Other classes that persist this need to know when our id changed, so they can
            clean up the old copy which is based on the old name.
            </summary>
        </member>
        <member name="P:Palaso.WritingSystems.WritingSystemDefinition.ScriptOption">
            <summary>
            If we don't have an option for the current script, returns null
            </summary>
        </member>
        <member name="P:Palaso.WritingSystems.WritingSystemDefinition.NativeName">
            <summary>
            The windows "NativeName" from the Culture class
            </summary>
        </member>
        <member name="P:Palaso.WritingSystems.WritingSystemDefinition.Collator">
            <summary>
            Returns an ICollator interface that can be used to sort strings based
            on the custom collation rules.
            </summary>
        </member>
        <member name="F:Palaso.WritingSystems.WritingSystemDefinition.SortRulesType.DefaultOrdering">
            <summary>
            Default Unicode ordering rules
            </summary>
        </member>
        <member name="F:Palaso.WritingSystems.WritingSystemDefinition.SortRulesType.CustomSimple">
            <summary>
            Custom Simple (Shoebox/Toolbox) style rules
            </summary>
        </member>
        <member name="F:Palaso.WritingSystems.WritingSystemDefinition.SortRulesType.CustomICU">
            <summary>
            Custom ICU rules
            </summary>
        </member>
        <member name="F:Palaso.WritingSystems.WritingSystemDefinition.SortRulesType.OtherLanguage">
            <summary>
            Use the sort rules from another language. When this is set, the SortRules are interpretted as a cultureId for the language to sort like.
            </summary>
        </member>
        <member name="P:Palaso.UiBindings.IBindableControl`1.Value">
            <summary>
            The value or a key, as appropriate
            </summary>
        </member>
        <member name="P:Palaso.UiBindings.IValueHolder`1.Value">
            <summary>
            The value or a key, as appropriate
            </summary>
        </member>
        <member name="T:Spart.Parsers.Composite.RepetitionParser">
            <summary>
            matches a given range of count of the given parser
            </summary>
        </member>
        <member name="T:Spart.Parsers.UnaryTerminalParser">
            <summary>
            abstract unary parser
            </summary>
        </member>
        <member name="M:Spart.Parsers.UnaryTerminalParser.#ctor(Spart.Parsers.Parser)">
            <summary>
            constructor
            </summary>
            <param name="parser"></param>
        </member>
        <member name="P:Spart.Parsers.UnaryTerminalParser.Parser">
            <summary>
            The associated parser
            </summary>
        </member>
        <member name="M:Spart.Parsers.Composite.RepetitionParser.#ctor(Spart.Parsers.Parser,System.Int32,System.Int32)">
            <summary>
            constructor
            </summary>
            <param name="parser">the parser to match</param>
            <param name="lowerBound">the least number of valid occurrences</param>
            <param name="upperBound">the most number of valid occurrences</param>
        </member>
        <member name="M:Spart.Parsers.Composite.RepetitionParser.SetBounds(System.Int32,System.Int32)">
            <summary>
            set the range of the amount of occurrences of the parser allowed
            </summary>
            <param name="lower_bound">the least amount of occurrences allowed</param>
            <param name="upper_bound">the most amount of occurrences allowed</param>
        </member>
        <member name="M:Spart.Parsers.Composite.RepetitionParser.ParseMain(Spart.Scanners.IScanner)">
            <summary>
            Inner parse method
            </summary>
            <param name="scanner">scanner</param>
            <returns>the match</returns>
        </member>
        <member name="P:Spart.Parsers.Composite.RepetitionParser.LowerBound">
            <summary>
            the least amount of occurrences of the parser allowed
            </summary>
        </member>
        <member name="P:Spart.Parsers.Composite.RepetitionParser.UpperBound">
            <summary>
            the most amount of occurrences of the parser allowed
            </summary>
        </member>
        <member name="T:Palaso.Resource">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Palaso.Resource.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Palaso.Resource.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Palaso.Resource.languageCodes">
             <summary>
               Looks up a localized string similar to Id	Part2B	Part2T	Part1	Scope	Type	Ref_Name
            aaa				I	L	Ghotuo
            aab				I	L	Alumu-Tesu
            aac				I	L	Ari
            aad				I	L	Amal
            aae				I	L	Arbresh Albanian
            aaf				I	L	Aranadan
            aag				I	L	Ambrak
            aai				I	L	Arifama-Miniafia
            aak				I	L	Ankave
            aal				I	L	Afade
            aam				I	L	Aramanik
            aan				I	L	Anamb
            aao				I	L	Algerian Saharan Arabic
            aap				I	L	Par Arra
            aaq				I	E	Eastern Abnaki
            aar	aar	aar	aa	I	L	Afar
            aas				I	L	Aasx
            aat				I	L	Arvanitika Albanian
            aau				I	L	Abau
            aaw				I	L	Solong
            aax				I	L	Mandobo  [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:Palaso.Resource.scriptNames">
             <summary>
               Looks up a localized string similar to #
            # ISO 15924 - Codes for the representation of names of scripts
            #             Codes pour la reprsentation des noms dcritures
            # Format: 
            #             Code;N;English Name;Nom franais;PVA;Date
            #
            
            Arab;160;Arabic;arabe;Arabic;2004-05-01
            Armn;230;Armenian;armnien;Armenian;2004-05-01
            Avst;134;Avestan;avestique;;2007-07-15
            Bali;360;Balinese;balinais;Balinese;2006-10-10
            Batk;365;Batak;batak;;2004-05-01
            Beng;325;Bengali;bengal;Bengali;2004-05-01
            Blis;550;Blissymbols;symboles Bliss;;2004-05-01
             [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="M:Palaso.Reporting.ProblemNotificationDialog.#ctor(System.String,System.String)">
            <summary>
            Use this one if you need to customize the dialog, e.g. to setup an alternate button
            </summary>
            <param name="message"></param>
            <param name="dialogTitle"></param>
        </member>
        <member name="F:Palaso.Reporting.ProblemNotificationDialog.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:Palaso.Reporting.ProblemNotificationDialog.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:Palaso.Reporting.ProblemNotificationDialog.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="M:Palaso.i18n.StringCatalog.#ctor">
            <summary>
            Construct with no actual string file
            </summary>
        </member>
        <member name="M:Palaso.i18n.StringCatalog.#ctor(System.String,System.Single)">
            <summary>
            Construct with no actual string file
            </summary>
        </member>
        <member name="M:Palaso.i18n.StringCatalog.GetFormatted(System.String,System.String,System.Object[])">
            <summary>
            Clients should use this rather than running string.Format themselves,
            because this has error checking and a helpful message, should the number
            of parameters be wrong.
            </summary>
            <param name="id"></param>
            <param name="translationNotes">just for the string scanner's use</param>
            <param name="args">arguments to the string, used in string.format</param>
            <returns></returns>
        </member>
        <member name="M:Palaso.WritingSystems.LdmlInFolderWritingSystemStore.#ctor">
            <summary>
            Use the default repository
            </summary>
        </member>
        <member name="M:Palaso.WritingSystems.LdmlInFolderWritingSystemStore.#ctor(System.String)">
            <summary>
            use a special path for the repository
            </summary>
            <param name="path"></param>
        </member>
        <member name="P:Palaso.WritingSystems.LdmlInFolderWritingSystemStore.SystemWritingSystemProvider">
            <summary>
            Provides writing systems from a repository that comes, for example, with the OS
            </summary>
        </member>
        <member name="M:Palaso.WritingSystems.LdmlSharedWritingSystemCollection.#ctor">
            <summary>
            Use the default repository
            </summary>
        </member>
        <member name="T:Spart.Scanners.ToLowerFilter">
            <summary>
            A to lower input filter
            </summary>
        </member>
        <member name="T:Spart.Scanners.IFilter">
            <summary>
            Input filter interface
            </summary>
        </member>
        <member name="M:Spart.Scanners.IFilter.Filter(System.String)">
            <summary>
            Converts string to anther string
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:Spart.Scanners.IFilter.Filter(System.Char)">
            <summary>
            Converts c to another char
            </summary>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:Spart.Scanners.ToLowerFilter.Filter(System.String)">
            <summary>
            Converts s to lower string
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:Spart.Scanners.ToLowerFilter.Filter(System.Char)">
            <summary>
            Converts i to lower i
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="T:Spart.Parsers.NonTerminal.Rule">
            <summary>
            A rule is a parser holder.
            </summary>
        </member>
        <member name="M:Spart.Parsers.NonTerminal.Rule.#ctor">
            <summary>
            Empty rule creator
            </summary>
        </member>
        <member name="M:Spart.Parsers.NonTerminal.Rule.#ctor(System.String)">
            <summary>
            Constructs a rule with an id (used for debugging)
            </summary>
            <param name="id">rule id (used for debugging)</param>
        </member>
        <member name="M:Spart.Parsers.NonTerminal.Rule.#ctor(Spart.Parsers.Parser)">
            <summary>
            Creates a rule and assign parser
            </summary>
            <param name="p"></param>
        </member>
        <member name="M:Spart.Parsers.NonTerminal.Rule.#ctor(System.String,Spart.Parsers.Parser)">
            <summary>
            Creates a rule with an idand assign parser
            </summary>
            <param name="p"></param>
            <param name="id">rule id (used for debugging)</param>
        </member>
        <member name="M:Spart.Parsers.NonTerminal.Rule.ParseMain(Spart.Scanners.IScanner)">
            <summary>
            Inner parse method
            </summary>
            <param name="scanner"></param>
            <returns></returns>
        </member>
        <member name="P:Spart.Parsers.NonTerminal.Rule.Parser">
            <summary>
            Rule parser
            </summary>
        </member>
        <member name="P:Spart.Parsers.NonTerminal.Rule.Item(Spart.Actions.ActionHandler)">
            <summary>
            Applies the given action handler to this parser
            </summary>
            <remarks>
            This is syntactic sugar to allow Rules to use shorthand and not require a cast
            </remarks>
            <param name="act">An ActionHandler</param>
            <returns>this</returns>
        </member>
        <member name="T:Spart.Parsers.NonTerminal.PreParseEventHandler">
            <summary>
            Handle pre parse events
            </summary>
            <param name="sender"></param>
            <param name="args"></param>
        </member>
        <member name="T:Palaso.Reporting.UsageEmailDialog">
            <summary>
            Summary description for UsageEmailDialog.
            </summary>
        </member>
        <member name="F:Palaso.Reporting.UsageEmailDialog.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:Palaso.Reporting.UsageEmailDialog.CheckDisposed">
            <summary>
            Check to see if the object has been disposed.
            All public Properties and Methods should call this
            before doing anything else.
            </summary>
        </member>
        <member name="M:Palaso.Reporting.UsageEmailDialog.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
        </member>
        <member name="M:Palaso.Reporting.UsageEmailDialog.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="P:Palaso.Reporting.UsageEmailDialog.TopLineText">
            <summary>
            
            </summary>
        </member>
        <member name="F:Palaso.Reporting.ErrorReport.s_properties">
            <summary>
            a list of name, string value pairs that will be included in the details of the error report.
            </summary>
        </member>
        <member name="M:Palaso.Reporting.ErrorReport.GetExceptionText(System.Exception)">
            ------------------------------------------------------------------------------------
            <summary>
            
            </summary>
            <param name="error"></param>
            <returns></returns>
            ------------------------------------------------------------------------------------
        </member>
        <member name="M:Palaso.Reporting.ErrorReport.AddProperty(System.String,System.String)">
            ------------------------------------------------------------------------------------
            <summary>
            add a property that he would like included in any bug reports created by this application.
            </summary>
            ------------------------------------------------------------------------------------
        </member>
        <member name="M:Palaso.Reporting.ErrorReport.GetHiearchicalExceptionInfo(System.Exception,System.Exception@)">
            ------------------------------------------------------------------------------------
            <summary>
            
            </summary>
            <returns></returns>
            ------------------------------------------------------------------------------------
        </member>
        <member name="M:Palaso.Reporting.ErrorReport.NotifyUserOfProblem(System.String,System.Object[])">
            <summary>
            Put up a message box, unless OkToInteractWithUser is false, in which case throw an Appliciation Exception.
            This will not report the problem to the developer.  Use one of the "report" methods for that.
            </summary>
        </member>
        <member name="M:Palaso.Reporting.ErrorReport.ReportNonFatalExceptionWithMessage(System.Exception,System.String,System.Object[])">
            <summary>
            Bring up a "yellow box" that let's them send in a report, then return to the program.
            </summary>
        </member>
        <member name="M:Palaso.Reporting.ErrorReport.ReportNonFatalMessageWithStackTrace(System.String,System.Object[])">
            <summary>
            Bring up a "yellow box" that let's them send in a report, then return to the program.
            Use this one only when you don't have an exception (else you're not reporting the exception's message)
            </summary>
        </member>
        <member name="M:Palaso.Reporting.ErrorReport.ReportFatalMessageWithStackTrace(System.String,System.Object[])">
            <summary>
            Bring up a "green box" that let's them send in a report, then exit.
            </summary>
        </member>
        <member name="M:Palaso.Reporting.ErrorReport.ReportNonFatalException(System.Exception)">
            <summary>
            Bring up a "yellow box" that lets them send in a report, then return to the program.
            </summary>
        </member>
        <member name="M:Palaso.Reporting.ErrorReport.ReportNonFatalException(System.Exception,Palaso.Reporting.IRepeatNoticePolicy)">
            <summary>
            Allow user to report an exception even though the program doesn't need to exit
            </summary>
        </member>
        <member name="P:Palaso.Reporting.ErrorReport.EmailAddress">
            <summary>
            set this property if you want the dialog to offer to create an e-mail message.
            </summary>
        </member>
        <member name="P:Palaso.Reporting.ErrorReport.EmailSubject">
            <summary>
            set this property if you want something other than the default e-mail subject
            </summary>
        </member>
        <member name="P:Palaso.Reporting.ErrorReport.Properties">
            <summary>
            a list of name, string value pairs that will be included in the details of the error report.
            </summary>
        </member>
        <member name="T:Palaso.Reporting.ErrorReport.NonFatalErrorReportExpected">
            <summary>
            use this in unit tests to cleanly check that a message would have been shown.
            E.g.  using (new Palaso.Reporting.ErrorReport.NonFatalErrorReportExpected()) {...}
            </summary>
        </member>
        <member name="P:Palaso.Reporting.ErrorReport.NonFatalErrorReportExpected.Message">
            <summary>
            use this to check the actual contents of the message that was triggered
            </summary>
        </member>
        <member name="T:Palaso.Reporting.ErrorReport.ProblemNotificationSentToUserException">
            <summary>
            this is for interacting with test code which doesn't want to allow an actual UI
            </summary>
        </member>
        <member name="T:Palaso.Reporting.ErrorReport.NonFatalExceptionWouldHaveBeenMessageShownToUserException">
            <summary>
            this is for interacting with test code which doesn't want to allow an actual UI
            </summary>
        </member>
        <member name="M:Palaso.IO.FileLocator.GetFileDistributedWithApplication(System.String[])">
            <summary>
            Find a file which, on a development machine, lives in [solution]/[distFileFolderName]/[subPath],
            and when installed, lives in 
            [applicationFolder]/[distFileFolderName]/[subPath1]/[subPathN]  or
            [applicationFolder]/[subPath]/[subPathN]
            </summary>
            <example>GetFileDistributedWithApplication("info", "releaseNotes.htm");</example>
        </member>
        <member name="M:Palaso.IO.FileLocator.GetDirectoryDistributedWithApplication(System.String[])">
            <summary>
            Find a file which, on a development machine, lives in [solution]/DistFiles/[subPath],
            and when installed, lives in 
            [applicationFolder]/[subPath1]/[subPathN]
            </summary>
            <example>GetFileDistributedWithApplication("info", "releaseNotes.htm");</example>
        </member>
        <member name="P:Palaso.IO.FileLocator.DirectoryOfApplicationOrSolution">
            <summary>
            Gives the directory of either the project folder (if running from visual studio), or
            the installation folder.  Helpful for finding templates and things; by using this,
            you don't have to copy those files into the build directory during development.
            It assumes your build directory has "output" as part of its path.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Palaso.Code.Guard">
            <summary>
            Helper class for guard statements, which allow prettier
            code for guard clauses
            </summary>
        </member>
        <member name="M:Palaso.Code.Guard.Against(System.Boolean,System.String)">
            <summary>
            Will throw a <see cref="T:System.InvalidOperationException"/> if the assertion
            is true, with the specificied message.
            </summary>
            <param name="assertion">if set to <c>true</c> [assertion].</param>
            <param name="message">The message.</param>
            <example>
            Sample usage:
            <code>
            Guard.Against(string.IsNullOrEmpty(name), "Name must have a value");
            </code>
            </example>
        </member>
        <member name="M:Palaso.Code.Guard.Against``1(System.Boolean,System.String)">
            <summary>
            Will throw exception of type <typeparamref name="TException"/>
            with the specified message if the assertion is true
            </summary>
            <typeparam name="TException"></typeparam>
            <param name="assertion">if set to <c>true</c> [assertion].</param>
            <param name="message">The message.</param>
            <example>
            Sample usage:
            <code>
            <![CDATA[
            Guard.Against<ArgumentException>(string.IsNullOrEmpty(name), "Name must have a value");
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Palaso.IO.FileUtils.GrepFile(System.String,System.String,System.String)">
            <summary>
            NB: This will show a dialog if the file writing can't be done (subject to Palaso.Reporting settings).
            It will throw whatever exception was encountered, if the user can't resolve it.
            </summary>
            <param name="inputPath"></param>
            <param name="pattern"></param>
            <param name="replaceWith"></param>
        </member>
        <member name="M:Palaso.IO.FileUtils.ReplaceFileWithUserInteractionIfNeeded(System.String,System.String,System.String)">
            <summary>
            If there is a problem doing the replace, a dialog is shown which tells the user
            what happened, and lets them try to fix it.  It also lets them "Give up", in 
            which case this returns False.
            </summary>
            <param name="sourcePath"></param>
            <param name="destinationPath"></param>
            <param name="backupPath">can be null if you don't want a replacement</param>
            <returns>if the user gives up, throws whatever exception the file system gave</returns>
        </member>
        <member name="T:Spart.Debug.Debugger">
            <summary>
            A Debugger
            </summary>
        </member>
        <member name="M:Spart.Debug.Debugger.#ctor(Spart.Parsers.NonTerminal.IParserContext)">
            <summary>
            constructor
            </summary>
            <param name="context"></param>
        </member>
        <member name="M:Spart.Debug.Debugger.#ctor(System.IO.TextWriter)">
            <summary>
            constructor
            </summary>
            <param name="output"></param>
        </member>
        <member name="M:Spart.Debug.Debugger.op_Addition(Spart.Debug.Debugger,Spart.Parsers.NonTerminal.Rule)">
            <summary>
            Adds the debug context to the given rule
            </summary>
            <param name="debug"></param>
            <param name="rule"></param>
            <returns></returns>
        </member>
        <member name="P:Spart.Debug.Debugger.Context">
            <summary>
            The current parser context
            </summary>
        </member>
        <member name="T:Palaso.Reporting.ReportingStrings">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Palaso.Reporting.ReportingStrings.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Palaso.Reporting.ReportingStrings.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Palaso.Reporting.ReportingStrings.ks_Ok">
            <summary>
              Looks up a localized string similar to &amp;Ok.
            </summary>
        </member>
        <member name="P:Palaso.Reporting.ReportingStrings.ksPleaseEMailThisToUs">
             <summary>
               Looks up a localized string similar to Please e-mail this to {0} 
            
            {1}.
             </summary>
        </member>
        <member name="P:Palaso.Reporting.ReportingStrings.kstidFieldWorksErrorCaption">
            <summary>
              Looks up a localized string similar to Error.
            </summary>
        </member>
        <member name="P:Palaso.Reporting.ReportingStrings.kstidFieldWorksErrorExitInfo">
            <summary>
              Looks up a localized string similar to This application must exit..
            </summary>
        </member>
        <member name="T:Palaso.Data.PreciseDateTime">
            <summary>
            Pseudo precise in that the ticks value returned does not actually
            conform to the definition of Ticks but will be strictly increasing
            each time it is called.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Palaso.UiBindings.StringToObjectEnumerableWrapper" -->
        <member name="T:Palaso.Text.LanguageForm">
            <summary>
            A LanguageForm is a unicode string plus the id of its writing system
            </summary>
        </member>
        <member name="F:Palaso.Text.LanguageForm._parent">
            <summary>
            See the comment on MultiText._parent for information on 
            this field.
            </summary>
        </member>
        <member name="M:Palaso.Text.LanguageForm.#ctor">
            <summary>
            for netreflector
            </summary>
        </member>
        <member name="P:Palaso.Text.LanguageForm.Parent">
            <summary>
            See the comment on MultiText._parent for information on 
            this field.
            </summary>
        </member>
        <member name="T:Spart.Parsers.Primitives.CharParser">
            <summary>
            Matches any character that the given character recognizer recognizes
            </summary>
        </member>
        <member name="T:Spart.Parsers.NegatableParser">
            <summary>
            A parser that can be negated (will match anything that it would not have matched and won't match anything it would have matched)
            </summary>
        </member>
        <member name="M:Spart.Parsers.NegatableParser.op_OnesComplement(Spart.Parsers.NegatableParser)">
            <summary>
            Negate this parser
            </summary>
            <param name="p">the parser to negate</param>
            <returns></returns>
        </member>
        <member name="P:Spart.Parsers.NegatableParser.Negate">
            <summary>
            Should this parser be negated
            </summary>
        </member>
        <member name="M:Spart.Parsers.Primitives.CharParser.#ctor(Spart.Parsers.Primitives.Testers.CharRecognizer)">
            <summary>
            constructor
            </summary>
            <param name="tester">The character recognizer to use to match</param>
        </member>
        <member name="M:Spart.Parsers.Primitives.CharParser.ParseMain(Spart.Scanners.IScanner)">
            <summary>
            Inner parse method
            </summary>
            <param name="scanner">scanner</param>
            <returns>the match</returns>
        </member>
        <member name="P:Spart.Parsers.Primitives.CharParser.Accepts">
            <summary>
            Character tester to use to determine if we have a match
            </summary>
        </member>
        <member name="T:Spart.Parsers.NonTerminal.PostParseEventArgs">
            <summary>
            Arguments associated with the PostParse event
            </summary>
        </member>
        <member name="M:Spart.Parsers.NonTerminal.PostParseEventArgs.#ctor(Spart.Parsers.ParserMatch,Spart.Parsers.NonTerminal.NonTerminalParser,Spart.Scanners.IScanner)">
            <summary>
            Constructs a post parse event args
            </summary>
            <param name="match"></param>
            <param name="parser"></param>
            <param name="scanner"></param>
        </member>
        <member name="P:Spart.Parsers.NonTerminal.PostParseEventArgs.Match">
            <summary>
            The associated match
            </summary>
        </member>
        <member name="P:Spart.Parsers.NonTerminal.PostParseEventArgs.Parser">
            <summary>
            The current parser
            </summary>
        </member>
        <member name="P:Spart.Parsers.NonTerminal.PostParseEventArgs.Scanner">
            <summary>
            the current scanner
            </summary>
        </member>
        <member name="T:Palaso.Reporting.ExceptionHelper">
            <summary>
            Helper class that makes it easier to get information out of nested exceptions to 
            display in the UI.
            </summary>
        </member>
        <member name="M:Palaso.Reporting.ExceptionHelper.#ctor">
            <summary>
            Not intended to be instantiated, because it contains only static methods
            </summary>
        </member>
        <member name="M:Palaso.Reporting.ExceptionHelper.GetAllExceptionMessages(System.Exception)">
            <summary>
            Get the messages from all nested exceptions
            </summary>
            <param name="e">The exception</param>
            <returns>String with the messages of all nested exceptions</returns>
        </member>
        <member name="M:Palaso.Reporting.ExceptionHelper.GetExceptionTypes(System.Exception)">
            <summary>
            Gets the exception types of all nested exceptions.
            </summary>
            <param name="e">The exception</param>
            <returns>String with the types of all nested exceptions. The string has the
            form type1(type2(type3...)).</returns>
        </member>
        <member name="M:Palaso.Reporting.ExceptionHelper.GetAllStackTraces(System.Exception)">
            <summary>
            Gets a string with the stack traces of all nested exceptions. The stack
            for the inner most exception is displayed first. Each stack is preceded
            by the exception type, module name, method name and message.
            </summary>
            <param name="e">The exception</param>
            <returns>String with stack traces of all nested exceptions.</returns>
        </member>
        <member name="M:Palaso.Reporting.ExceptionHelper.GetTargetSiteNames(System.Exception)">
            <summary>
            Gets the names of all the target sites of nested exceptions.
            </summary>
            <param name="e">The exception</param>
            <returns>String with the names of all the target sites.</returns>
        </member>
        <member name="M:Palaso.Reporting.ExceptionHelper.GetInnerMostException(System.Exception)">
            <summary>
            Gets the inner most exception
            </summary>
            <param name="e">The exception</param>
            <returns>Returns the inner most exception.</returns>
        </member>
        <member name="M:Palaso.Reporting.ExceptionHelper.GetHelpLink(System.Exception)">
            <summary>
            Gets the help string.
            </summary>
            <param name="e">The exception</param>
            <returns>The help link</returns>
        </member>
        <member name="T:Palaso.Reporting.ErrorReportTests">
            <summary>
            Summary description for ErrorReportTests.
            </summary>
        </member>
        <member name="M:Palaso.Reporting.ErrorReportTests.TestSend">
            <summary>
            
            </summary>
        </member>
        <member name="T:Palaso.Progress.InitializeProgressCallback">
            <summary>
            Delegate for a method which allows the progress range to be reset
            </summary>
        </member>
        <member name="T:Palaso.Progress.ProgressCallback">
            <summary>
            Delegate for a method which allows the progress to be updated
            </summary>
        </member>
        <member name="T:Palaso.Progress.StatusCallback">
            <summary>
            Delegate for a method which allows the status text to be updated
            </summary>
        </member>
        <member name="M:Palaso.Progress.BasicCommand.BeginInvokeCore">
            <summary>
            Implementation of the async work invoker
            </summary>
            <remarks>
            We're using the delegate BeginInvoke() / EndInvoke() pattern here
            </remarks>
        </member>
        <member name="T:Palaso.Progress.WorkInvoker">
            <summary>
            Delegate for a worker method which provides additional callbacks
            </summary>
        </member>
        <member name="T:Spart.Debug.DebugContext">
            <summary>
            A Debug Context
            </summary>
        </member>
        <member name="M:Spart.Debug.DebugContext.#ctor(System.IO.TextWriter)">
            <summary>
            constructor
            </summary>
            <param name="output"></param>
        </member>
        <member name="M:Spart.Debug.DebugContext.PreParse(System.Object,Spart.Parsers.NonTerminal.PreParseEventArgs)">
            <summary>
            handle the preparse event
            </summary>
            <param name="sender"></param>
            <param name="args"></param>
        </member>
        <member name="M:Spart.Debug.DebugContext.PostParse(System.Object,Spart.Parsers.NonTerminal.PostParseEventArgs)">
            <summary>
            handle the postparse event
            </summary>
            <param name="sender"></param>
            <param name="args"></param>
        </member>
        <member name="P:Spart.Debug.DebugContext.Output">
            <summary>
            The output Text Writer
            </summary>
        </member>
        <member name="P:Spart.Debug.DebugContext.Tab">
            <summary>
            A string with the current indentation suitable for prepending to output that should be nested
            </summary>
        </member>
        <member name="M:Palaso.WritingSystems.Collation.AddSortKeysToXml.AddSortKeys(System.Xml.XPath.XPathNavigator,System.String,Palaso.WritingSystems.Collation.AddSortKeysToXml.SortKeyGenerator,System.String,System.String)">
            <summary>
            Annotate an xml document with a sort key suitable for xslt version 1 sorting algorithms (use lang='en')
            </summary>
            <param name="document">input to add sort keys to</param>
            <param name="xpathSortKeySource">an xpath that selects the source to use to create a sort key</param>
            <param name="sortKeyGenerator">delegate that returns a SortKey given a string</param>
            <param name="xpathElementToPutSortKeyAttributeIn">a relative xpath (from the source) that selects the element to put the sortkey attribute in</param>
            <param name="attribute">The sort key attribute</param>
        </member>
        <member name="M:Palaso.WritingSystems.Collation.AddSortKeysToXml.AddSortKeys(System.Xml.XPath.XPathNavigator,System.String,Palaso.WritingSystems.Collation.AddSortKeysToXml.SortKeyGenerator,System.String,System.String,System.String,System.String)">
            <summary>
            Annotate an xml document with a sort key suitable for xslt version 1 sorting algorithms (use lang='en')
            </summary>
            <param name="document">input to add sort keys to</param>
            <param name="xpathSortKeySource">an xpath that selects the source to use to create a sort key</param>
            <param name="sortKeyGenerator">delegate that returns a SortKey given a string</param>
            <param name="xpathElementToPutSortKeyAttributeIn">a relative xpath (from the source) that selects the element to put the sortkey attribute in</param>
            <param name="prefix">The prefix of the sort-key attribute</param>
            <param name="attribute">The sort key attribute</param>
            <param name="namespaceUri">The namespace of the sortkey attribute</param>
        </member>
        <member name="T:Spart.Parsers.Composite.ListParser">
            <summary>
            recognize a list of one or more repetitions of first parser seperated by occurrences of 
            the second parser (the delimiter). This is equivalent to:
            Sequence(first, ZeroOrMore(Sequence(second, first))
            a must not also match b!
            </summary>
        </member>
        <member name="M:Spart.Parsers.Composite.ListParser.#ctor(Spart.Parsers.Parser,Spart.Parsers.Parser)">
            <summary>
            constructs a list parser that recognizes items separated by a delimiter
            </summary>
            <param name="first">item</param>
            <param name="second">delimiter</param>
        </member>
        <member name="M:Spart.Parsers.Composite.ListParser.ParseMain(Spart.Scanners.IScanner)">
            <summary>
            Inner parse method
            </summary>
            <param name="scanner">scanner</param>
            <returns>the match</returns>
        </member>
        <member name="T:Spart.Actions.ActionHandler">
            <summary>
            Action handler delegate
            </summary>
        </member>
        <member name="M:Palaso.Extensions.StringExtensions.CombineForPath(System.String,System.String[])">
            <summary>
            Similar to Path.Combine, but it combines as may parts as you have into a single, platform-appropriate path.
            </summary>
            <example> string path = "my".Combine("stuff", "toys", "ball.txt")</example>
        </member>
        <member name="T:Palaso.Progress.BackgroundWorkerState">
            <summary>
            Long-running tasks can be written to take one of these as an argument, and use it to notify others of their progress
            </summary>
        </member>
        <member name="T:Palaso.WritingSystems.LdmlNodeComparer">
            <summary>
            Class for comparison of order of nodes in an LDML document.
            Based on http://www.unicode.org/cldr/data/docs/design/ldml_canonical_form.html
            The supplemental metadata shipped with the current CLDR release will have more complete
            element and attribute order data.
            </summary>
        </member>
        <member name="M:Palaso.WritingSystems.LdmlNodeComparer.CompareAttributeValues(System.Xml.XmlNode,System.Xml.XmlNode)">
            <summary>
            Compares two attribute values.  There is a value order table that defines the order of values
            for some attributes of some elements.  After that, sort in numeric order, and then in alphabetic order.
            There is a more complicated rule for the "type" attribute of the "zone" element, but since we're
            not using that element at this time, I'm not going to try to write code for it.
            </summary>
        </member>
        <member name="T:Spart.Parsers.ParserMatch">
            <summary>
            A parser match
            </summary>
        </member>
        <member name="M:Spart.Parsers.ParserMatch.CreateSuccessfulMatch(Spart.Scanners.IScanner,System.Int64,System.Int32)">
            <summary>
            Builds a new successful match
            </summary>
            <param name="scanner">The scanner used while matching</param>
            <param name="startOffset">The position at which the match started</param>
            <param name="length">The lenthg of the stream successfully matched</param>
        </member>
        <member name="M:Spart.Parsers.ParserMatch.CreateSuccessfulMatch(Spart.Scanners.IScanner,System.Int64,System.Int64)">
            <summary>
            Builds a new successful match ending at the current position of the scanner
            </summary>
            <param name="scanner">The scanner used while matching</param>
            <param name="startOffset">The position at which the match started</param>
            <param name="endOffset">The position at which the match ends</param>
        </member>
        <member name="M:Spart.Parsers.ParserMatch.CreateSuccessfulMatch(Spart.Scanners.IScanner,System.Int64)">
            <summary>
            Builds a new successful match ending at the current position of the scanner
            </summary>
            <param name="scanner">The scanner used while matching</param>
            <param name="startOffset">The position at which the match started</param>
        </member>
        <member name="M:Spart.Parsers.ParserMatch.CreateSuccessfulEmptyMatch(Spart.Scanners.IScanner,System.Int64)">
            <summary>
            Builds a new successful empty match
            </summary>
            <param name="scanner">The scanner used while matching</param>
            <param name="offset">The position at which the match started</param>
        </member>
        <member name="M:Spart.Parsers.ParserMatch.CreateSuccessfulEmptyMatch(Spart.Scanners.IScanner)">
            <summary>
            Builds a new successful empty match at the current position of the scanner
            </summary>
            <param name="scanner">The scanner used while matching</param>
        </member>
        <member name="M:Spart.Parsers.ParserMatch.CreateFailureMatch(Spart.Scanners.IScanner,System.Int64,System.Int32)">
            <summary>
            Create a failure match
            </summary>
            <param name="scanner">The scanner used while matching</param>
            <param name="startOffset">The position at which the match started</param>
            <param name="length">The end of the stream successfully matched</param>
        </member>
        <member name="M:Spart.Parsers.ParserMatch.CreateFailureMatch(Spart.Scanners.IScanner,System.Int64,System.Int64)">
            <summary>
            Create a failure match
            </summary>
            <param name="scanner">The scanner used while matching</param>
            <param name="startOffset">The position at which the match started</param>
            <param name="endOffset">The position of the end of the stream successfully matched before failure</param>
        </member>
        <member name="M:Spart.Parsers.ParserMatch.CreateFailureMatch(Spart.Scanners.IScanner,System.Int64)">
            <summary>
            Create a failure match ending at the current position of the scanner
            </summary>
            <param name="scanner">The scanner used while matching</param>
            <param name="startOffset">The position at which the match started</param>
        </member>
        <member name="M:Spart.Parsers.ParserMatch.CreateFailureMatch(Spart.Scanners.IScanner)">
            <summary>
            Create a failure match beginning and ending at the current position of the scanner
            </summary>
            <param name="scanner">The scanner used while matching</param>
        </member>
        <member name="M:Spart.Parsers.ParserMatch.Concat(Spart.Parsers.ParserMatch)">
            <summary>
            Concatenates match with m
            </summary>
            <param name="m"></param>
        </member>
        <member name="P:Spart.Parsers.ParserMatch.Scanner">
            <summary>
            Scanner
            </summary>
        </member>
        <member name="P:Spart.Parsers.ParserMatch.Offset">
            <summary>
            Offset
            </summary>
        </member>
        <member name="P:Spart.Parsers.ParserMatch.Length">
            <summary>
            Length
            </summary>
        </member>
        <member name="P:Spart.Parsers.ParserMatch.Value">
            <summary>
            Extracts the match value
            </summary>
        </member>
        <member name="P:Spart.Parsers.ParserMatch.Success">
            <summary>
            True if match successfull
            </summary>
        </member>
        <member name="P:Spart.Parsers.ParserMatch.Empty">
            <summary>
            True if match empty
            </summary>
        </member>
        <member name="T:Spart.Parsers.Ops">
            <summary>
            Static helper class to create new parser operators
            </summary>
        </member>
        <member name="M:Spart.Parsers.Ops.Sequence(Spart.Parsers.Parser[])">
            <summary>
            &gt;&gt; operator
            </summary>
            <param name="args">A list of parsers</param>
            <returns>A sequence parser</returns>
        </member>
        <member name="M:Spart.Parsers.Ops.Choice(Spart.Parsers.Parser[])">
            <summary>
            | operator
            </summary>
            <param name="args">a list of the parsers to alternate between</param>
            <returns></returns>
        </member>
        <member name="M:Spart.Parsers.Ops.Intersection(Spart.Parsers.Parser[])">
            <summary>
            &amp; operator
            </summary>
            <param name="args">a list of the parsers to intersect</param>
            <returns></returns>
        </member>
        <member name="M:Spart.Parsers.Ops.Difference(Spart.Parsers.Parser,Spart.Parsers.Parser)">
            <summary>
            - operator
            </summary>
            <param name="first">A parser to recognize</param>
            <param name="second">A parser to not recognize</param>
            <returns></returns>
        </member>
        <member name="M:Spart.Parsers.Ops.List(Spart.Parsers.Parser,Spart.Parsers.Parser)">
            <summary>
            % operator
            </summary>
            <param name="first">A parser that recognizes the item(s)</param>
            <param name="second">A parser that recognizes the delimiter</param>
            <returns></returns>
        </member>
        <member name="M:Spart.Parsers.Ops.ZeroOrMore(Spart.Parsers.Parser)">
            <summary>
            * operators
            </summary>
            <param name="parser"></param>
            <returns></returns>
        </member>
        <member name="M:Spart.Parsers.Ops.OneOrMore(Spart.Parsers.Parser)">
            <summary>
            + operator
            </summary>
            <param name="parser"></param>
            <returns></returns>
        </member>
        <member name="M:Spart.Parsers.Ops.Optional(Spart.Parsers.Parser)">
            <summary>
            ! operator
            </summary>
            <param name="parser"></param>
            <returns></returns>
        </member>
        <member name="T:Spart.Parsers.Composite.AlternativeParser">
            <summary>
            Matches if one of the given parsers matches (union)
            </summary>
        </member>
        <member name="M:Spart.Parsers.Composite.AlternativeParser.#ctor(Spart.Parsers.Parser,Spart.Parsers.Parser)">
            <summary>
            constructor
            </summary>
            <param name="first">one alternative</param>
            <param name="second">another alternative</param>
        </member>
        <member name="M:Spart.Parsers.Composite.AlternativeParser.ParseMain(Spart.Scanners.IScanner)">
            <summary>
            Inner parse method
            </summary>
            <param name="scanner">scanner</param>
            <returns>the match</returns>
        </member>
        <member name="M:Palaso.Reporting.ExceptionReportingDialog.CheckDisposed">
            <summary>
            Check to see if the object has been disposed.
            All public Properties and Methods should call this
            before doing anything else.
            </summary>
        </member>
        <member name="M:Palaso.Reporting.ExceptionReportingDialog.Dispose(System.Boolean)">
            <summary>
            Executes in two distinct scenarios.
            
            1. If disposing is true, the method has been called directly
            or indirectly by a user's code via the Dispose method.
            Both managed and unmanaged resources can be disposed.
            
            2. If disposing is false, the method has been called by the 
            runtime from inside the finalizer and you should not reference (access) 
            other managed objects, as they already have been garbage collected.
            Only unmanaged resources can be disposed.
            </summary>
            <param name="disposing"></param>
            <remarks>
            If any exceptions are thrown, that is fine.
            If the method is being done in a finalizer, it will be ignored.
            If it is thrown by client code calling Dispose,
            it needs to be handled by fixing the bug.
            
            If subclasses override this method, they should call the base implementation.
            </remarks>
        </member>
        <member name="M:Palaso.Reporting.ExceptionReportingDialog.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="M:Palaso.Reporting.ExceptionReportingDialog.ReportException(System.Exception)">
            ------------------------------------------------------------------------------------
            <summary>
            show a dialog or output to the error log, as appropriate.
            </summary>
            <param name="error">the exception you want to report</param>
            ------------------------------------------------------------------------------------
        </member>
        <member name="M:Palaso.Reporting.ExceptionReportingDialog.ReportException(System.Exception,System.Windows.Forms.Form)">
            <summary>
            
            </summary>
            <param name="error"></param>
            <param name="parent"></param>
        </member>
        <member name="M:Palaso.Reporting.ExceptionReportingDialog.ReportException(System.Exception,System.Windows.Forms.Form,System.Boolean)">
            ------------------------------------------------------------------------------------
            <summary>
            show a dialog or output to the error log, as appropriate.
            </summary>
            <param name="error">the exception you want to report</param>
            <param name="parent">the parent form that this error belongs to (i.e. the form
            show modally on)</param>
            ------------------------------------------------------------------------------------
            <param name="isLethal"></param>
        </member>
        <member name="M:Palaso.Reporting.ExceptionReportingDialog.GatherData">
            ------------------------------------------------------------------------------------
            <summary>
            
            </summary>
            ------------------------------------------------------------------------------------
        </member>
        <member name="M:Palaso.Reporting.ExceptionReportingDialog.btnClose_Click(System.Object,System.EventArgs)">
            ------------------------------------------------------------------------------------
            <summary>
            
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
            ------------------------------------------------------------------------------------
        </member>
        <member name="M:Palaso.Reporting.ExceptionReportingDialog.OnKeyDown(System.Windows.Forms.KeyEventArgs)">
            ------------------------------------------------------------------------------------
            <summary>
            Shows the attempt to continue label if the shift key is pressed
            </summary>
            <param name="e"></param>
            ------------------------------------------------------------------------------------
        </member>
        <member name="M:Palaso.Reporting.ExceptionReportingDialog.OnKeyUp(System.Windows.Forms.KeyEventArgs)">
            ------------------------------------------------------------------------------------
            <summary>
            Hides the attempt to continue label if the shift key is pressed
            </summary>
            <param name="e"></param>
            ------------------------------------------------------------------------------------
        </member>
        <member name="T:Palaso.Progress.NullProgressState">
            <summary>
            Use this when you don't have an actual progressstate installed and don't
            want to litter the code with if(_progressState != null)'s
            </summary>
        </member>
        <member name="P:Palaso.Progress.NullProgressState.NumberOfStepsCompleted">
            <summary>
            How much the task is done
            </summary>
        </member>
        <member name="P:Palaso.Progress.NullProgressState.StatusLabel">
            <summary>
            a label which describes what we are busy doing
            </summary>
        </member>
        <member name="M:Palaso.Email.MAPI.SendMail(System.String,System.String,System.Int32)">
            <summary>
            
            </summary>
            <param name="strSubject"></param>
            <param name="strBody"></param>
            <param name="how"></param>
            <returns>true if successful</returns>
        </member>
        <member name="M:Palaso.Data.ResultSetCache`1.UpdateItemInCache(`0)">
            <summary>
            Call this method every time a cached item changes. This method verifies that the item you are trying to update exists int he repository.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Palaso.Reporting.Network.ProxyCredentialsRequestDialog.GetCredentials(System.Boolean)">
            <summary>
            
            </summary>
            <param name="doTryStoredCredentials">Call it first with this true, but if that doesn't work, call with this
            false so that we ask the user again</param>
            <returns></returns>
        </member>
        <member name="F:Palaso.Reporting.Network.ProxyCredentialsRequestDialog.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:Palaso.Reporting.Network.ProxyCredentialsRequestDialog.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:Palaso.Reporting.Network.ProxyCredentialsRequestDialog.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="M:Palaso.Reporting.Network.RobustNetworkOperation.Do(System.Action{System.Net.IWebProxy})">
            <summary>
            Perform a web action, trying various things to use a proxy if needed, including requesting
            (and remembering) user credentials from the user.
            </summary>
            <param name="action"></param>
        </member>
    </members>
</doc>
